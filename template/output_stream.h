#if !defined output_stream_h
#define output_stream_h

#include "layer.h"

/**
 * 
 * @author Laouen Louan Mayal Belloli
 * @date 14 May 2017
 * 
 * @class output_stream output_stream.h
 * 
 * @brief Template meta model of an output_stream model. Once instanciated, this
 * model is initialized with a file_path pointing to the file where to write the
 * input generated. 
 * This model receives messages of type DATA and it uses the << operator to write
 * the message and the time at which the message has arrives in the file specified
 * by the file_path parameter.
 * 
 * @details This model must be inherited by a new class with the template DATA
 * parameter specified with the input type to generate.
 * 
 * The new class must follow the PowerDEVS specifications and a .cpp file must 
 * exist even if it is an empty file in order to correctly compile the model 
 * from the PowerDEVS IDE.
 * 
 * The next rules must be followed:
 * 1. This file must be included in the file where the new class is declared.
 * 2. The new class name must be all lower case.
 * 3. The new class must have in the first line the next comment: 
 *        //CPP:networkDEVS/new_class_name.cpp.
 * 4. The file networkDEVS/new_class_name.cpp must exist as an empty file.
 * 5. The constructor of the new class must be specified in the public section as shown here: 
 *        new_class_name(const char *n): output_stream(n) {};
 *        
 * The parameters to specifie in the PowerDEVS IDE (right click in the atomic
 * model -> edit -> parameters) are the nexts:
 * 
      name    |      type     |                    description
:-----------: | :-----------: | :--------------------------------------------------:
 module name  |    String     | a name used to tag the logs generated by this model
 file path    |    String     | the file path from where to write the output
 * 
 * @tparam DATA The data type of the input to generate. Must implement the << operator
 */

template<typename DATA>
class output_stream: public Simulator {
  Logger logger;
  std::ofstream file;
  double infinity = std::numeric_limits<double>::max();

public:
  output_stream(const char *n): Simulator(n) {};

  void init(double t, ...) {
    // PowerDEVS parameters
    va_list parameters;
    va_start(parameters,t);

    // Set logger module name
    std::string module_name = va_arg(parameters,char*);
    logger.setModuleName("Input stream " + module_name);

    const char* file_path = va_arg(parameters,char*);
    file.open(file_path);
  }

  double ta(double t) {
    return infinity;
  }

  void dint(double t) {}

  void dext(Event x, double t) {

    if (x.port == 0) {
      DATA m = *(DATA*)x.value;
      file << "time:" << t << std::endl;
      file << m << std::endl << std::endl;
    }
  }

  Event lambda(double t) {
    return Event(0,0);
  }

  void exit() {
    file.close();
  }
};

#endif