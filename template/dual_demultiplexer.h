#if !defined demultiplexer_h
#define demultiplexer_h

#include <limits>

#include "simulator.h"
#include "event.h"
#include "stdarg.h"

#include "../libs/message_queue.h"
#include "../libs/logger.h"

#include "../structures/abstract_types.h"
#include "../structures/link.h"

/**
 * 
 * @author Laouen Louan Mayal Belloli
 * @date 14 May 2017
 * 
 * @class DDemultiplexer dual_demultiplexer.h
 * 
 * @brief Template meta model of a demultiplexer that receives a 
 * message::multiplexed<DATA> or message::multiplexed<CTRL> in the input port number 
 * zero/one and returns the encapsulated message through the port indicated 
 * by the interface field of the multiplexed instance.
 * 
 * @details This model must be inherited by a new class with the templates DATA 
 * and CTRL parameter specified with the same data type that is specified in the
 * message::multiplexed type that will arrives to this model.
 * 
 * The new class must follow the PowerDEVS specifications and a .cpp file must 
 * exist even if it is an empty file in order to correctly compile the model 
 * from the PowerDEVS IDE.
 * 
 * The next rules must be followed:
 * 1. This file must be included in the file where the new class is declared.
 * 2. The new class name must be all lower case.
 * 3. The new class must have in the first line the next comment: 
 *        //CPP:networkDEVS/new_class_name.cpp.
 * 4. The file networkDEVS/new_class_name.cpp must exist as an empty file.
 * 5. The constructor of the new class must be specified in the public section as shown here: 
 *        new_class_name(const char *n): demultiplexer(n) {};
 * 
 * The parameters to specifie in the PowerDEVS IDE (right click in the atomic
 * model -> edit -> parameters) are the nexts:
 * 
      name    |      type     |                    description
:-----------: | :-----------: | :--------------------------------------------------:
 module name  |    String     | a name used to tag the logs generated by this model
 * 
 * @tparam DATA The data type of the template parameter DATA of the 
 * message::Multiplexed message that arrives in the input port zero.
 * @tparam CTRL The data type of the template parameter CTRL of the 
 * message::Multiplexed message that arrives in the input port one.
 */
template<typename DATA, typename CTRL>
class DDemultiplexer: public Simulator { 
  Logger logger;

  message::queue<DATA> _output_queue_data;
  message::queue<CTRL> _output_queue_ctrl;
  unsigned int _max_interface;
  Event _output;

  double infinity = std::numeric_limits<double>::max();

public:

  DDemultiplexer(const char *n): Simulator(n) {}

  void init(double t, ...) {
    // PowerDEVS parameters
    va_list parameters;
    va_start(parameters,t);

    // Set logger module name
    std::string module_name = va_arg(parameters, char*);
    logger.setModuleName("DDemultiplexer " + this->getName());

    // Set interface amount
    _max_interface = (unsigned int)va_arg(parameters,double);
    _output = Event(0, 2*_max_interface+2);

    logger.info("Initialized with " + 
                std::to_string(_max_interface) + 
                " interfaces");
  }

  double ta(double t) {
    return (_output.port >= _max_interface) ? infinity : 0;
  }

  void dint(double t) {
    _output = Event(0, 2*_max_interface+2);
  }

  void dext(Event x, double t) {
    message::Multiplexed<DATA> multiplexed_data;
    message::Multiplexed<CTRL> multiplexed_ctrl;

    if (x.port == 0) {
      multiplexed_data = *(message::Multiplexed<DATA>*)x.value;
      if (multiplexed_data.interface <= _max_interface) {
        _output = _output_queue.send(multiplexed_data.message, 2*multiplexed_data.interface);
      }
    } else if (x.port == 1) {
      multiplexed_ctrl = *(message::Multiplexed<CTRL>*)x.value;
      if (multiplexed_ctrl.interface <= _max_interface) {
        _output = _output_queue.send(multiplexed_ctrl.message, 2*multiplexed_ctrl.interface+1);
      }
    }
  }

  Event lambda(double t) {
    return _output;
  }

  void exit() {}
};

#endif