TODO:

1)
1 byte = 8 bits
Un ushort tiene 16 bits equivalentes a 2 bytes. y un unsigned char tiene 8 bits equivalentes a 1 byte.
Hay que mirar todos los tipos de dato utilizados en las estructuras de IPv4, MAC, Headers, etc para ver
que cada campo tiene un tipo de dato con tamaño correspondiente.

2) 
Ver como matchear IPv4 interfaces con las interfaces fisicas, si eso se le pasa a la capa 2 o si
hay una capa dos por cada interfaz.

3)
El campo interfaz aparece en distintos lugares como parte de la tabla de routing, lo cual en realidad
proviene del hecho de que creo que ambas tablas (forwarding and routing tables) las implementan como una sola.
Pero la pregunta es: de donde se supone que se aprende la interfaz. Utilizando ARP no se aprende y no dice como se
obtiene. Segun Peterson pagina 240 en la seccion 3.3 Routing dice:

"The forwarding table is used when a packet is being forwarded and so must
contain enough information to accomplish the forwarding function. This
means that a row in the forwarding table contains the mapping from a
network prefix to an outgoing interface and some MAC information, such
as the Ethernet address of the next hop"

3.1)
La interfaz es elegida en la capa IP (en TCP/IP), ̉¿lo mismo vale en este modelo? ¿implementamos un modelo
de capa 2 por cada interfaz? Actualmente no estoy utilizando el campo IPv4 interfaz.

4)
No logro ver si hay un timeout en ARP para cuanto tiempo se queda esperando y en tiempo de que se 
acabe el tiempo cual es el error que se produce. O si se queda al eterno esperando la mac de una IP
para un paquete.

5)
Mirar con Rodrigo que onda el algoritmo de ARP y la forwarding table, actualmente estoy matcheando
nexthop IPv4 a MAC addresses, pero en los libros aparece como que implementa subneting en la forwarding
table. No me queda claro si el subneting proviene de mezclar ambas tablas o si tienen un uso distinto o que.

6) Mirar checksum, ver si la tira de caracteres tiene que estar alineada a 16 bits o no. Petterson pagina 94
sección 2.4.2

7) Hacer que la capa IP pueda trabajar tanto con paquetes UDP como TCP.

8) Ver el algoritmo de SWP para el sender en la linea: 
	slot = &state->sendQ[state->hdr.SeqNum % SWS];
no me queda claro que ese modulo no rompa el ciclo cuando SeqNum hace overlflow y vuelva a 0;

9) Mirar si es correcto poner ARP este en capa 3 o si prefiere que esté en capa 2. Se supone que es lo que 
se dice que está en capa 2.5. Ver donde prefiere Rodrigo que esté y en tal caso de que esta bién en capa 3
ver si está bien que la capa 3 envie link::Frames o si esos frames se deberian crear en capa 2.

10) Por la red se pueden enviar distintos packetes, ARP, IP, etc. No encuentro cual es el mecanismo mediante
el cual se indica cual de todos es para castear correctamente la información entrante.

11) actualmente estoy usando el campo preamble del link::Frame como header donde guardo los datos del header de SWP
y tambien donde indico si es un ARP o IP packet. Esto lo inventé yo ya que no encuentro bien donde es que va 
esa información, a la misma vez tampoco encontre para que está el preamble y entonces lo use para estas cosas.

12) que pasa con las capas mas bajas cuando le llegan packetes de capas mas altas con distintos headers y por ende 
tal vez con distintos tamaños, deberia manejarse esto de alguna manera especial? No encontré info al respecto y el 
modelo como implemento un solo protocolo para cada capa esta como "Hardcodeado", no esta literalmente hardcodeado pero
mas o menos si. Lo mejor que pense, es que para cada capa superior puede haber un modelo distinto donde los packetes 
de la capa superior se convierten en template, por desgracia PowerDEVS no permite tener modelos templates. 