\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[spanish, es-tabla]{babel} % para que comandos como \today den el resultado en castellano
\usepackage{a4wide} % márgenes un poco más anchos que lo usual
\usepackage[conEntregas]{caratula}
\usepackage[table]{xcolor}
\usepackage{colortbl}
\usepackage{todonotes}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{dirtree}
\usepackage{cite}
\usepackage{listings}
\usepackage{multirow}
\usepackage{epsfig}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{verbatim}

\lstset { %
    language=C++,
    backgroundcolor=\color{green!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

%definations
\definecolor{Gray}{gray}{0.6}
\definecolor{ligthGray}{gray}{0.9}
\newcommand{\mc}[2]{\multicolumn{#1}{|c|}{#2}}

\hyphenation{UDP/IP}

\usepackage{verbatim}

\begin{document}	

\titulo{Trabajo Práctico Final}
\subtitulo{NetworkDEVS: Una herramienta de simulación para la enseñanza de redes de datos}

\fecha{\today}

\materia{Teoría de las Comunicaciones}

\integrante{Belloli, Laouen Mayal Louan}{134/11}{laouen.belloli@gmail.com}

\maketitle

\tableofcontents
\newpage

\section{Introducción y Motivación}

El presente trabajo introduce un modelo DEVS de una red funcionando bajo el protocolo UDP/IP encuadrando lo mejor posible cada uno de sus módulos en su correspondiente capa respecto al modelo OSI presentado en la literatura oficial de la materia de teoría de la comunicaciones \cite{peterson2011computer}. El trabajo fue desarrollado en el simulador PowerDEVS y pensado como herramienta de estudio para futuros alumnos de la materia. \\

Además del modelo, este trabajo aporta un framework que permite programar y modificar los protocolos de una red de comunicaciones para luego simular su comportamiento y obtener feedback instantáneo de los resultados. También, usando el simulador PowerDEVS, se consigue brindar una interfaz gráfica intuitiva que mapea de forma directa los dispositivos de la red con los módulos del modelo. Esta interfaz gráfica permite crear distintos escenarios topológicos sin tener que tocar ni una linea de código. \\

Por otro lado, esta interfaz gráfica permite modularizar de forma explícita las distintas capas del modelo y sus interacciones. De esta forma, se programa cada protocolo en su capa correspondiente, esto no es menor, ya que si bien, teóricamente, los distintos protocolos están separados en capas y las redes pueden ser pensadas así, en la realidad, estas capas no existen de forma explicita y hay un salto entre las teorías de redes y los modelos en capas respecto de sus distintas implementaciones prácticas. Este modelo, permite a los alumnos hacer trabajos prácticos implementando los protocolos y manteniendo explicitas estas capas, por ende, permite acercar la teoría y la práctica de las redes de comunicaciones. \\

Si bien, el modelo realizado es un modelo DEVS (Discrete EVent System Specification), el mismo fue pensado para que no sea necesario más que una breve introducción al formalismo, por lo que mismo personas sin ninguna experiencia en DEVS deberían ser capases de poder utilizar el simulador, el modelo y el framework general propuesto en este trabajo. De todas formas, una explicación detallada sobre DEVS y PowerDEVS puede ser encontrada en \cite{bergero2011powerdevs}, un documento donde los autores de PowerDEVS explican con detalles, el formalismo DEVS y el simulador PowerDEVS. \\

\section{Objetivos}

Los objetivos de este trabajo se pueden dividir en varias partes:
\subsection{Desarrollar un framework para modelos de redes}

Como ya fue mencionado en la introducción, uno de los principales objetivos de este trabajo es desarrollar un framework, que permita fácilmente implementar protocolos de red, validarlos y experimentar con ellos mediante Simulación de Eventos Discretos (DES). Esta herramienta permite testear los protocolos implementados de forma sencilla y rápida. Obteniendo una herramienta útil, tanto para el estudio de las redes de comunicaciones como para la investigación en el área. 

La creación de un modelo que sirva como framework, tiene por objetivo factorizar y estandarizar las partes comunes a todos los protocolos, estás partes comunes provienen de las propiedades inherentes a los dispositivos físicos en los cuales los protocolos están corriendo, y de los estándares actualmente utilizados que permiten obtener robustez y compatibilidad entre distintas implementaciones que puedan existir en distintas partes de una red. Estas abstracciones encapsuladas en el modelo framework presentado, permiten al modelador, concentrarse plenamente en su protocolo y permite la reutilización y compatibilidad de distintos modelos que pueden luego ser combinados en un único modelo de una red que funcione bajo distintos protocolos, permitiendo así el estudio de la compatibilidad, homogeneidad y efectividad de los protocolos implementados.

\subsection{Modelar una red UDP/IP básica}

Por otro lado, este trabajo implementa un modelo básico de una red UDP/IP que permita cubrir los protocolos mínimos e indispensables para permitir enviar mensajes entre distintos dispositivos. Este modelo no tiene como intensión implementar todas las partes, ni cubrir todos los protocolos, por lo que temáticas como la fragmentación de paquetes, congestión de tráfico, manejo de errores, Dinamic Host Configuration Protocol (DHCP) \cite[p.~231]{peterson2011computer}, Routing Information Protocol (RIP)\cite[p.~243]{peterson2011computer} y Spanning tree protocol \cite[p.~194]{peterson2011computer} quedan fuera del alcance de este trabajo, siendo los mismos posibles trabajos futuros. \\

También se implementó un modelo de switch que utiliza el protocolo Datagramas \cite[p.~172]{peterson2011computer} utilizando una forwarding table para enviar los Frames por la interface correspondiente. \\

Para completar el modelo, se implementó el protocolo DNS correspondiente a la capa de aplicación y se simuló un escenario en el cual un host desea obtener la dirección ip de otro host, cuyo dominio es network.devs.com.

\subsection{Mapeo entre el modelo UDP/IP y el modelo OSI}

En este trabajo, también pretendemos mostrar como se pueden implementar los distintos protocolos del modelo UDP/IP encuadrándolos en un modelo en capas OSI. Para esto, varias decisiones tuvieron que tomarse, siendo tal vez la más difícil, decidir en que capa implementar el protocolo ARP \cite[p.~228]{peterson2011computer}. Para tomar estas decisiones, se tomaron siempre como referencia los textos del libro oficial de la materia \cite{peterson2011computer}. Se intentó también separar lo mejor posible las tareas de cada capa de forma tal que cada una de ellas pueda ignorar lo más posible la existencia de la o las capas inferiores.

\section{Arquitectura}

\subsubsection{Conceptos básicos de la arquitectura}

La arquitectura general del modelo propuesto en este trabajo tiene por principal objetivo ofrecer un framework donde se pueda fácilmente desarrollar protocolos, para esto, se concentra en resolver varios puntos principales:

\begin{itemize}
\item Estandarizar la comunicación entre las capas de forma de conseguir consenso entre los distintos modeladores que usen esta herramienta, y que facilite una comprensión jerárquica y organizada del modelo entero para los lectores nuevos.
\item Implementar todas aquellas partes generales a todos los modelos de protocolos de forma que solo sea necesario concentrarse en el protocolo a implementar.
\item Minimizar lo más posible la necesidad de tener conocimientos avanzados sobre DEVS a la hora de utilizar la herramienta.
\end{itemize}

\newpage

\subsubsection{Arquitectura implementada}
La arquitectura consiste en un modelo acoplado \textit{dispositivo} de $N$ capas (cada capa además es un modelo acoplado), con $N > 0$. Cada capa $i, i \in [1,..,N]$ contiene uno o más modelos atómicos con los distintos protocolos de la capa y se comunica con las capas $i+1$ e $i-1$ utilizando $8$ canales de comunicación distintos:

\begin{itemize}
\item Output port 0: Envío de datos a la capa $i+1$.
\item Output port 1: Envío de controles a la capa $i+1$.
\item Output port 2: Envío de datos a la capa $i-1$.
\item Output port 3: Envío de controles a la capa $i-1$.
\item Input port 0: Recepción de datos de la capa $i+1$.
\item Input port 1: Recepción de controles de la capa $i+1$.
\item Input port 2: Recepción de datos de la capa $i-1$.
\item Input port 3: Recepción de controles de la capa $i-1$.
\end{itemize}

Dado que no siempre sucede que en un dispositivo de la red, exista un solo módulo/protocolo por capa, y dado que los puertos de salida y entradas están pensados para comunicarse con un solo modelo en la capa superior e inferior. Es necesario usar modelos demultiplexers que permitan redirigir los mensajes salientes por un puerto al modelo correspondiente de entre todas las posibles opciones.\\

Ejemplos de estos son: 
\begin{itemize}
\item Un host que tiene varias aplicaciones enviando datos a través de distintos protocolos (UDP, TCP, etc): Hay más de un módulo en la capa de transporte (capa cuatro del modelo OSI) de ese host.
\item  Un router que tiene más de una interfaz: Hay una interfaz por cada sub-red a la cual esté conectado, contando con más de un modulo en la capa de linkeo (capa dos del modelo OSI).
\end{itemize}

Las capas $1$ y $N$ usan la misma arquitectura que el resto de las capas y tienen definidos los mismos puertos con las diferencias siguientes:
\begin{itemize}
\item Capa $1$:
\begin{itemize}
\item Los dispositivos pueden tener más de un puerto físico por donde reciven y envian datos a otros dispositivos (nodos) de la red, es por esto que para la capa $1$ no sirve la estandarización realizada mediante modelos demultiplexers y cada protocolo de esta red debe mapearse correctamente a los distintos puertos de entrada y salida del dispositivo. Para este trabajo podría ser necesario o no la utilización de demultiplexers aunque en general se puede pensar que existe un protocolo por cada interfaz física y el mapeo es uno a uno.
\item Como existe un único medio de comunicación físico por cada puerto físico del dispositivo, por donde los datos de cualquier tipo son enviados y recividos, la capa $1$ debe tener un solo puerto de salida y un solo puerto de entrada destinados a comunicarse con los puertos físicos de entrada y salida del dispositivo, queda en el modelador decidir como mapear los puertos de salida y entrada de los protocolos (2 puertos de entrada y 2 de salida) de la capa $1$ con los puertos de entrada y salida del modelo acoplado (1 puerto de entrada y 1 de salida)\footnote{comunmente  ambos puertos de salida de los protocolos son mapeados al único puerto de salida de la capa y el puerto de entrada de la capa es mapeado al puerto de entrada de datos de los protocolos sin recibir mensajes de contros de otros dispositivos}.
\end{itemize}
\item Capa $N$: El input requerido por la capa $N$ (comunmente el input que indica los pedidos del usuario de enviar o recibir datos) se pueden obtener mediante modelos generadores situados adentro del modelo del dispositivo. Lo mismo ocurre con el output generado por la capa $N$, este output puede ser recibido por modelos vertederos que lo guardan en archivos.
\end{itemize}

Distintos dispositivos de la red pueden tener distintas cantidades de capas, por lo cual, la cantidad de capas existente puede variar entre los distintos modelos de cada dispositivo dentro de una misma red. Los hosts por ejemplo, suelen tener hasta la capa siete, mientras que los routers comunes llegan a la capa tres y los switches a la capa dos. Este framework de modelado permite una cantidad variables $N$ de capas. \\

La Figura \ref{figure:general architecture} muestra la arquitectura general recién explicada; En el mismo se pueden ver los multiplexers que comunican las entradas de cada capa con los protocolos, los generadores y vertederos conectados a la última capa, el mapeo de los protocolos con los puertos de entrada y salida de cada capa, el mapeo entre capas y el mapeo de los puertos de los protocolos de la capa 1 destinados a salir del dispositivo. \\

\begin{figure}[!bht]
    \centering
    \includegraphics[width = 0.75\textwidth]{img/png/general_architecture.png}
    \caption{Arquitectura de un modelo en NetworkDEVS mostrando dos dispositivos de N y M capas correspondientemente.}
    \label{figure:general architecture}
\end{figure}

\newpage

\subsubsection{Arquitectura de los protocolos}

La arquitectura de los protocolos está implementada en un modelo template llamado \textit{Protocol} del cual se puede realizar herencia para heredar su estructura. Esta estructura permite abstraer al protocolo de todo el modelo correspondiente a la comunicación con el exterior manejando el envío y recepción de mensajes a y desde el modelo acoplado de la capa al protocolo. Para manejar la entrada y salida de mensajes se utilizan colas FIFO; Cada vez que hay un mensaje entrante, el mismo es automaticamente encolado en la cola de entrada correspondiente y el protocolo los va desencolando y atendiendo de a uno o de a muchos dependiendo la implementación, el modelo template ya está armado de forma que mientras que no haya mensajes por procesar se mantiene pasivado (en estado IDLE) y mientras que hay mensajes por procesar se queda ciclando para ir atendiéndolos a todos hasta que no halla más mensajes a procesar, momento en el que el modelo se vuelve a pasivar. Por otro lado, cada vez que se quiere enviar un mensaje, el mismo solo debe ser encolado en la cola de mensajes salientes correspondiente dependiendo de si es un mensaje de datos o control a la capa superior o inferior, luego el simulador cuando el protocolo termina el procesamiento actual se encarga de ciclar entre las colas de salida para enviar todos los mensajes que fueron encolados. La Figura \ref{figure:protocol general architecture} muestra la arquitectura general de un protocolo cualquiera y la Figura \ref{figure:processing flow} muestra el flujo de procesamiento generado por el modelo template cuando es extendido agregándole una implementación particular al protocolo.

\begin{figure}[!bht]
    \centering
    \includegraphics[width = 0.5\textwidth]{img/png/protocol_architecture.png}
    \caption{Arquitectura de un protocolo en NetworkDEVS.}
    \label{figure:protocol general architecture}
\end{figure}

\begin{figure}[!bht]
    \centering
    \includegraphics[width = 0.55\textwidth]{img/png/processing_flow.png}
    \caption{Flujo de procesamiento de un protocolo que extiende al modelo template Protocol. El estado \textit{Procesando mensajes} es el estado que representa al protocolo mientras que la función \textit{protocol implementation} con la implementación particular del protocolo está siendo ejecutada para procesar los mensajes encolados en las colas de entrada del protocolo.}
    \label{figure:processing flow}
\end{figure}

\newpage

\section{Como usar el template}

Todo el modelo está implementado en C++ y la forma de usar el template es mediante la implementación de herencias. Para poder comprender como utilizarlo, primero introduciremos la estructura de archivos del framework. \\

\dirtree{%
.1 NetworkDEVS.
.2 libs.
.3 logger.h.
.3 message\_queue.h.
.3 parser.h.
.2 structures.
.3 abstract\_types.h.
.3 ipv4.h1.
.3 mac.h.
.3 socket.h.
.2 templates. 
.3 protocol.h.
.3 demultiplexer.h.
.3 input\_stream.h.
.3 output\_strem.h.
.2 LICENSE.
.2 README.md.
}

\medskip

La carpeta \textit{structures} es la que contiene las definiciones de todos los tipos de datos que vienen por defecto con el framework, algunos de ellos fueron implementados exclusivamente para el modelo presentado en este trabajo, pero todos pueden ser utilizados y están incluidos por el modelo template \textit{Protocol} que introduciremos a continuación. Los tipos de datos están implementados usando structs y casi todos heredan de dos tipos abstractos definidos en \textit{abstract\_types.h} que sirven como organizadores (Header y Data). De esta forma quedan separados entre los que son Data y los que son Headers. Cada tipo de dato definido cuenta con documentación en el código en formato Doxygen. \\

Todos los tipos de datos están implementados en namespaces que sirven como organizadores. Para cada protocolo existente debe existir un namespace y los tipos de datos inherentes a ese protocolo tienen que estar definidos dentro del namespace (por más que otros protocolos lo usen). Si se implementan nuevos protocolos, se deben crear sus correspondientes namespaces a menos que no haya tipos de datos correspondientes al nuevo protocolo. De está forma se evitan las ambigüedades que son muy recurrentes en el ámbito de las redes y se explicita la interacción con los datos correspondientes a cada capa. \\

\textbf{Nota: } No están incluidos en esta estructura todos los archivos puntuales al modelo particular implementado, solo se encuentran aquellos archivos correspondientes a la arquitectura del framework. \\

\subsection{Como heredar el modelo protocol}

El modelo \textit{Protocol} es el modelo template que contiene toda la implementación correspondiente a la arquitectura general de un protocolo. El mismo es un modelo que cuenta con $4$ tipos de datos templates a instanciar y $4$ tipos de datos template con instanciación por defecto si no se explicitaran otros tipos para ellos. Estos tipos a instanciar son los tipos de los mensajes que envían y reciben los puertos y los tipos con los cuales se definen las colas. Por defecto se asume que los modelos intercambian los mismos tipos de datos, por ejemplo, si dos modelos intercambian datos de control, estos datos son del mismo tipo en ambas direcciones, sin importar quien es el que los envia y quien es el que los recibe. Es por esto que hay solo 4 tipos template que deben ser instanciados obligatoriamente, mientras que los restantes cuatro se mapean por defecto con los primeros 4. De todas formas, si se desea que los tipos de datos no sean iguales dependiendo quien envía y quien recibe, se pueden instanciar todos los tipos template.\\

El modelo \textit{Protocol} tiene la siguiente forma:
\begin{lstlisting}
template <typename DH, CH, DL, CL, DHout = DH, CHout = CH, DLout = DL, CLout = CL>
class Protocol: public Simulator { 

protected:
  // Logger
  Logger logger;

  // Colas de entrada
  std::queue<DH> higher_layer_data_in; // Input Port 0
  std::queue<DL> lower_layer_data_in;  // Input Port 1
  std::queue<CH> higher_layer_ctrl_in; // Input Port 2 
  std::queue<CL> lower_layer_ctrl_in;  // Input Port 3
  
  // Colas de salida
  message::queue<DHout> higher_layer_data_out = 0; // Output Port 0 
  message::queue<DLout> lower_layer_data_out = 1;  // Output Port 1
  message::queue<CHout> higher_layer_ctrl_out = 3; // Output Port 2
  message::queue<CLout> lower_layer_ctrl_out = 3;  // Output Port 3

  Event output;


  // Manipulacion del tiempo virtual de la simulacion 
  double next_internal;
  double last_transition;
  const double infinity = std::numeric_limits<double>::max();
  bool queuedMsgs() const { ... }

public:

  Protocol(const char *n): Simulator(n) {};
  double ta()
  Event lambda(double) { .... }
  void dint(double t) { .... }
  void dext(Event x, double t) { .... }
  
  virtual void protocol_implementation(double t) {}
  virtual void dexternal(double t) {}
};
\end{lstlisting}

PowerDEVS tiene un par de exigencias a la hora de declarar un nuevo modelo: \\

\begin{itemize}
\item La primer linea es requerida por el compilador de PowerDEVS y tiene que tener correctamente seteado la dirección al archivo \textit{.cpp} donde estén implementados todos los métodos del modelo.
\item El constructor de la clase debe estar declarado como se muestra en el ejemplo y la función \textit{init} es la utilizada por el simulador para inicializar el modelo. Esta función debe ser declarada como se muestra con los ``\ldots'' como parámetro, el simulador llama a esta función pasándole como primer parámetro \textit{double} la cantidad de parámetros a leer y luego el resto de los parámetros definidos para el modelo en la IDE PowerDEVS, los mismos se recuperan utilizando la librería \textit{va\_start} y \textit{va\_arg} \cite{vastart} \cite{vaarg}.
\item El método exit también debe ser declarado y el mismo es llamado por el simulador al finalizar la simulación. Todos los destructores correspondientes deben ser llamados en esta función de forma de liberar correctamente la memoria (de ser necesario).
\item El nombre de la clase debe estar escrito todo con minúsculas.
\end{itemize}

Como se puede observar existen las funciones \textit{dint} y \textit{dext} que son las funciones exigidas por el simulador para ejecutar correctamente las transiciones internas y externas correspondientes al formalismo DEVS, el modelo Protocol ejecuta en esas funciones todo el mecanismo relativo a la arquitectura presentada y llama a los métodos virtuales \textit{protocol\_implementation} y \textit{dexternal} que son sobre escritos por el modelador para ejecutar el protocolo implementado. De esta forma se consigue abstraer lo más posible al modelador del formalismo DEVS, convirtiendo esta herramienta en una herramienta viable para el uso dentro del ámbito de estudio. \\

Por otro lado, la variable \textit{next\_internal} definida en el template Protocol es utilizada por el modelo para agendar la próxima transición interna. Si el protocolo no asigna ningún valor a esta variable, se asume que el protocolo tomó infinito tiempo en procesar y el modelo quedará pasivado hasta que llegué nuevos mensajes externos. Una vez que se cumple el \textit{next\_time}, el output correspondiente es inmediatamente enviado y luego el modelo queda pasivado a menos que haya más mensajes externos a procesar. El desarrollador del protocolo tiene que asignar en esta esta variable un modelo del tiempo de computo del protocolo para de esta forma modelar los tiempos reales de runtime\footnote{Una opción es medir el tiempo real de procesamiento mediante librerias c++ para asignar el valor real de tiempo de computo.}. Esta variable es de tipo double y la representación del tiempo mediante doubles queda en manos del modelador y debe ser consensuada con el resto de los modeladores de los demás protocolos para poder unirlos en un solo modelo, un consenso común es asumir que una unidad de double representa un milisegundo y utilizarlo de forma igual a los timestamps. \\

A continuación se muestra un ejemplo de herencia que puede ser usado de base para implementar nuevos modelos de protocolos: \\

\begin{lstlisting}
//CPP:path_to_cpp_files/protocol_name.cpp
#include "template/protocol.h"

class protocol_name: public Protocol<T1, T2, T3, T4 [, T5, T6, T7, T8]> { 

protected:
	
  // Variables privadas del modelo
  // Metodos privados del modelo

public:
  protocol_name(const char *n): Protocol(n) {};
  void init(double t, ...);
  void exit();

  virtual void protocol_implementation(double t);
  virtual void dexternal(double t);
  
  // Variables publicas del modelo
  // Metodos publicos del modelo
};
\end{lstlisting}

\newpage

\subsection{Como enviar y recibir mensajes entre protocolos de distintas capas}

Todos los mensajes que llegan al modelo de un protocolo son recibidos por uno de los cuatro siguientes puertos dependiendo de donde provenga el mensaje:
\begin{itemize}
\item std::queue$<DH>$ higher\_layer\_data\_in:  Input Port 0
\item std::queue$<DL>$ lower\_layer\_data\_in:   Input Port 1
\item std::queue$<CH>$ higher\_layer\_ctrl\_in:  Input Port 2 
\item std::queue$<CL>$ lower\_layer\_ctrl\_in:   Input Port 3
\end{itemize}

La Figura \ref{figure:protocol general architecture} Muestra de que capa proviene y para que tipo de datos está pensado cada uno de estos puertos. \\

Como ya fue mencionado y como se puede observar en la definición de las colas, los tipos template instanciados son los tipos de los mensajes recibidos desde las capas superior e inferior. Es importante que los mensajes recibidos sean efectivamente de este tipo, porque el simulador PowerDEVS envía mensajes como \textbf{void *} y los mismos son casteados a su tipo correspondientes una vez recibidos por el modelo receptor, por lo que si los tipos no corresponden se generará un excepción en tiempo de ejecución. \\

Para procesar los mensajes, dentro del método \textit{protocol\_implementation}, los mismos deben ser desencolados, es importante que se desencolen, ya que en caso contrario el mismo seguirá estando en la cola y el modelo volverá a producir una transición interna y llamar de nuevo al método \textit{protocol\_implementation} procesando dos o más veces el mismo mensaje. Reprocesar un mensaje múltiple veces probablemente esté mal, pero tal vez es lo deseado por el protocolo, pero hay que tener en cuenta que una de las pocas exigencias del formalismo DEVS es que no ocurran infinitos eventos en un mismo momento del tiempo virtual, y como el modelo sigue generando transiciones internas mientras haya mensajes por procesar, si los mensajes no son desencolados nunca y la variable \textit{next\_internal} se mantiene en cero, se generan infinitas transiciones en tiempo cero y eso produciría un modelo DEVS ilegítimo que cuelga al simulador. \\

Para enviar mensajes las colas a utilizar son las siguientes:
\begin{itemize}
\item message::queue$<DHout>$ higher\_layer\_data\_out: Output Port 0 
\item message::queue$<DLout>$ lower\_layer\_data\_out:  Output Port 1
\item message::queue$<CHout>$ higher\_layer\_ctrl\_out: Output Port 2
\item message::queue$<CLout>$ lower\_layer\_ctrl\_out:  Output Port 3
\end{itemize}

Como se puede observar, los nombres de los tipos a instanciar son iguales a los de las colas de entrada con un \textit{out} al final, esto es porque los mismos por defecto se instancian usando los tipos de las colas de entrada a menos que en la declaración de la herencia se especifique lo contrario, esto es así ya que se considera buena práctica que el tipo de datos que intercambian dos modelos por un canal de comunicación sea siempre el mismo en ambas direcciones, facilitando la reutilización y comprensión de los modelos por parte de otras personas, sin embargo esto no es siempre posible. \\

Para encolar un mensaje en la cola de salida correspondiente se debe utilizar el método \textit{message::queue::push(MSG mensaje, int protocol\_id)}. De la misma forma que el modelo \textit{Protocol} se encarga de encolar los mensajes en la cola de entrada correspondiente dependiendo el puerto por donde llegó el mensaje, también se encarga de desencolar y enviar los mensajes encolados en las colas de salidas por el puerto correspondiente a cada cola y desencolar el mismo. \\

Por defecto y de forma automática, el modelo \textit{Protocol} envía los mensajes de forma multiplexada para ser demultiplexados en la capa destino del mensaje por su correspondiente demultiplexer (ver Figura \ref{figure:general architecture}), de esta forma, como ya fué mencionado previamente, es posible la interacción entre múltiples protocolos de una capa con múltiples protocolos de otra capa adjacente. Es por esto que cuando se encola un mensaje es necesario conocer el id del protocolo dentro del demultiplexer al que se le está enviando el mensaje, el mismo es pasado como parámetro a la función \textit{message::queue::push(MSG mensaje, int protocol\_id)}. Para poder comprender como se asignan los ids a los protocolos de forma de enviar y recibir mensajes correctamente, a continuación se explica el funcionamiento del tipo de datos message::multiplexed y del medelo \textit{demultiplexer}. \\

\subsubsection{Modelo dual\_demultiplexer (DDemultiplexer)}

El tipo de datos message::multiplexed$<typename\ MSG>$ sirve para enviar mensajes que van a ser demultiplexados por un modelo DDemultiplexer$<typename\ MSG>$. El mismo cuenta con los campos \textit{message} e \textit{interface} que son utilizados para asignar el mensaje y el identificador del destinatario (id del protocolo destino) correspondientemente. Luego solo resta utilizar un modelo \textit{DDemultiplexer}, setear correctamente sus parámetros en la IDE de PowerDEVS\footnote{Para setear parámetros en un modelo hay que hacer clic derecho $\rightarrow$ parameters}, y conectar correctamente sus puertos de entrada y salida con el modelo de origen y los modelos de destino, la Tabla \ref{table: parameter ddemultiplexer} explica los parámetros a setear en estos modelos. \\

El campo \textit{interface} le indica al \textit{DDemultiplexer} por que puerto enviar el mensaje, por lo que es importante conectar correctamente los puertos de salida del \textit{DDemultiplexer} con los puertos de entrada de los destinatarios. El mapeo de interfaces a puertos de salida de un \textit{DDemultiplexer} es el siguiente: \\

\begin{itemize}
\item Si el mensaje llega con un número de interfaz mayor o igual a Max\_interface, el mensaje es descartado.
\item Si el mensaje llega por el puerto $0$ del \textit{DDemultiplexer} con número de interfaz $i$, entonces el mensaje demultiplexado es enviado por el puerto de salida $2*i$.
\item Si el mensaje llega por el puerto $1$ del \textit{DDemultiplexer} con número de interfaz $i$, entonces el mensaje demultiplexado es enviado por el puerto de salida $2*i + 1$.
\end{itemize}

De está forma el modelo demultiplexa dos canales. La idea de demultiplexar dos canales proviene de que un puerto (en general el puerto 0) es el puerto de datos enviados por los puertos de salidas pares y el otro puerto es el puerto de controles enviado por los puertos de salida impares. De esta forma no es necesario tener un demultiplexer por cada canal (ver la arquitectura general en la Figura \ref{figure:general architecture}). \\

La entrada de mensages de datos del modelo $i$ de destino debe estar conectado al puerto de salida $2*i$ del demultiplexer y la de controles al puerto $2*i$+1, siendo entonces $i$ el id del protocolo para ese \textit{DDemultiplexer}, la Figura \ref{figure: demultiplexer} muestra el mapeo de puertos de un demultiplexer\footnote{En el modelo implementado en este trabajo hay ejemplos de como utilizar el modelo demultiplexer con el tipo de dato message::multiplexed}\footnote{Un demultiplexer con relación $1$ a $k$ numera los módulos de salida de $0$ a $k-1$}. \\

\begin{table*}[!hbt]
	\begin{tabular}{|l|c|c|c|}
  		\hline
  		\textbf{Nombre} & \textbf{Tipo} & \textbf{Descripción} \\
  		\hline
  		Module\_name & String & El nombre del módulo que utiliza el logger \\
  		\hline
  		Max\_interface & Int & La cantidad máximas de interfaces de salida que puede demultiplexar. \\
  		\hline
	\end{tabular}
	\caption{Parámetros del modelo \textit{DDemultiplexer}}
	\label{table: parameter ddemultiplexer}
\end{table*}

\begin{figure}[!hbt]
    \centering
    \includegraphics[width = 0.6\textwidth]{img/png/demultiplexer.png}
    \caption{Puertos de entrada y salida de un demultiplexer, mapeo del campo interfaz del mensaje con el puerto de salida correspondiente.}
    \label{figure: demultiplexer}
\end{figure}

\newpage

\subsection{Como implementar el protocolo de una capa (funciones protocol\_implementation y dexternal)}

El template cuenta con dos métodos virtuales que están definidos e implementados como funciones vacías (sin comportamiento), estos métodos son los que deben ser sobre escritos para implementar el protocolo. Siempre que haya mensajes por procesar en las colas de entradas, el modelo llama al método \textit{protocol\_implementation} en el cual se deben procesar dichos mensajes, el modelo \textit{Protocol} mira las colas de salida para ver si hay mensajes a enviar y los envía, si al finalizar este proceso sigue habiendo mensajes por procesar en las colas de entrada, se volverá a llamar a esta función respetando el formalismo DEVS de forma de seguir procesando mensajes. Este ciclo se repite indefinidamente hasta que no haya más mensajes por procesar, momento en el cual el modelo se pasiva a la espera de nuevos eventos externos. \\

El método virtual \textit{dexternal} existe por si se desea implementar código que se ejecute cada vez que ocurre un evento externo para modificar el estado de las variables internas del protocolo o por algún otro motivo. Esto no es recomendado para desarrolladores no familiarizados con el formalismo DEVS o con el simulador PowerDEVS. Para aquellas personas familiarizadas con el formalismo DEVS, tienen que tener en cuenta lo siguente: Si bien cada mensaje que llega genera una transición externa (implementada en el método \textit{dext} de PowerDEVS), lo único que hace es encolar los mensajes en la cola correspondiente y llamar a una transición interna inmediata solo si el modelo está actualmente pasivado (ya que al llegar mensajes nuevos deben ser procesados). Si el modelo no está pasivado, entonces está procesando un mensaje y cuando termine, al ver un nuevo mensaje va a procesarlo automaticamente. Los mensajes que son encolados son procesados en la función \textit{protocol\_implementation} que es llamada por el modelo template en la transición interna (en el método \textit{dint} de PowerDEVS) agendada de forma inmediata por la transición externa cuando llega un mensaje estando el modelo pasivado o por la transición interna anterior si el modelo tiene más de un mensaje a procesar. \\

\section{Como agregar un protocolo}

Hay dos tipos de modelos en el formalismo DEVS: los modelos atómicos y los modelos acoplados. Para implementar un modelo de protocolo nuevo, primero es necesario heredar del template Protocol para obtener el modelo atómico del protocolo como fue descripto en la sección anterior y luego el mismo debe ser insertado mediante la IDE PowerDEVS dentro del modelo acoplado de una capa dentro de un dispositivo. Luego, se deben conectar correctamente los puertos de entrada/salida del protocolo con los puertos de entrada/salida de la capa y del demultiplexer (Ver Figura \ref{figure:protocol general architecture}), luego en el dispositivo se interconectan todas las capas y en el \textit{TOP model} se interconectan todos los modelos acoplados de los dispositivos\footnote{En el caso de estudio de este trabajo se muestra un ejemplo complejo de las interconexiones entre capas y dispositivos}. \\

Como crear y abrir un modelo acoplado en PowerDEVS:
\begin{itemize}
\item \textbf{Crear un modelo acoplado en PowerDEVS: } Abrir la pestaña ``Basic Elements'' del sector ``library'' de la IDE y arrastrar el icono ``Coupled'' desde el menú hasta el sector donde esta el dibujo del modelo.
\item \textbf{Abrir un modelo acoplado en PowerDEVS:} Seleccionar con el mouse el modelo acoplado a abrir y desplegar el menú de opciones del mismo dando click derecho sobre el icono, luego elegir la opción ``open model''.
\end{itemize}

La figura \ref{figure: PowerDEVS IDE} muestra la IDE PowerDEVS e indica como crear un modelo acoplado dentro de la misma. \\

\begin{figure}[htb]
    \centering
    \includegraphics[width = 0.5\textwidth]{img/png/powerDEVS_coupled.png}
    \caption{Screenshot de la IDE PowerDEVS con la pestaña ``Basic Elements'' abierta resaltando el icono de coupled model.}
    \label{figure: PowerDEVS IDE}
\end{figure}

Para insertar un nuevo modelo de protocolo dentro de un modelo acoplado de capa en PowerDEVS hay que seguir los siguientes pasos:

\begin{enumerate}
\item Crear el modelo acoplado de capa (en caso de ser necesario) y abrirlo.
\item Crear un nuevo modelo atómico de protocolo:
\begin{enumerate}
\item De la solapa ``Basic Elements'' arrastrar al escenario el icono ``atomic''.
\item Click derecho sobre el icono del nuevo modelo atómico en el escenario.
\item Elegir la opción  ``edit''.
\item Ir a la pestaña ``code'', navegar por los modelos hasta encontrar el archivo \textit{.h} del modelo protocolo creado y seleccionarlo.
\item Ir a la pestaña ``parameters'' y agregar todos los parámetros requeridos por el modelo, o sea aquellos que el simulador le va a pasar al método ``init'' del modelo para inicializarlo y que serán leídos usando \textit{va\_arg} \footnote{Estos parámetros dependen de la implementación particular del protocolo.}.
\item Ir a la pestaña ``properties'' y realizar las siguientes tareas: Escribir el nombre deseado para el nuevo modelo, setear cuatro puertos de entrada y cuatro puertos de salida y elegir el icono a mostrar en el modelo (Elegir un icono no es obligatorio)
\end{enumerate}
\item Conectar las salidas y entradas del modelo según lo explicado anteriormente.
\end{enumerate}

Información más detallada sobre como usar PowerDEVS puede ser encontrada en el documento \cite{bergero2011powerdevs}, allí los autores describen como funciona el simulador y como crear un modelo desde el principio. \\

\section{Input/Output - Modelos generadores y vertederos} \label{section: I/O}
Para poder alimentar al modelo con eventos, es necesario contar con modelos específicos que sepan leer archivos, parsearlos y generar eventos para enviar a los otros modelos. Estos modelos son llamados generadores o \textit{sources} en ingles y si bien no forman parte del modelado del fenomeno, los mismos son una abstracción del mundo externo del modelo y permite modelar dicha interacción.

\subsection{Input}
Existen dos módulos responsables de leer el o los inputs del modelo, estos son: El modelo atómico template \textit{input\_stream} y la clase \textit{Parser}. La idea de separar el input en dos módulos es la de atacar dos problemáticas distintas pero similares:

\begin{itemize}
\item Contar con un parser que sepa leer archivos utilizados para inicializar modelos que requieren parámetros muy grandes \footnote{como por ejemplo las inicializaciones de las diferentes tablas utilizadas por el modelo (routing/forwarding tables)}.
\item Contar con un modelo generador que utilice el parser y se encargue de ir insertando los estímulos externos al modelo en el tiempo virtual correspondiente.\\
\end{itemize}

\subsection{La clase Parser}
Esta clase está diseñada como template y sirve para leer las lineas de un archivo y parsearlas con el fin de devolverlas en la estructura de datos correspondiente según la instanciación realizada. El \textit{typename INPUT} indica el tipo del input a parsear y el mismo debe implementar el operador std::istream \textsf{operator}$>>$(\textsf{std::istream}\& \textit{INPUT}\& i). Es importante que este operador este implementado de forma que lea todos los atributos necesarios sin saltos de linea ($\backslash n$) y que cada linea del archivo no contenga más de lo necesario para un solo input ya que el parser lee un input por linea.\\

La clase parser cuenta con dos métodos distintos para leer los datos del archivo:
\begin{itemize}
\item \textit{next\_timed\_input:} La linea del archivo a parsear debe comenzar con un valor \textit{double} que será devuelto por el parser de forma separada al input y que representa el tiempo en que debe ser insertado el input en la simulación, luego debe haber un espacio y el resto de la sintaxis requerida por el operador $>>$ del tipo de datos a parsear. 
\item \textit{next\_input:} No hace falta explicitar el tiempo como primer elemento de la linea y solo se devuelve el dato parseado por el operador $>>$.
\end{itemize}

\textbf{Nota:} Si bien el Parser tiene la opción para parsear el input junto con un tiempo asociado, el mismo no hace más que devolverlo en una tupla (tiempo, mensaje).\\

La clase Parser puede ser utilizada de forma independiente al modelo que lee input siempre que sea necesario leer y parsear las lineas de un archivo. La interfaz y documentación técnica del Parser está en formato Doxygen.

\subsection{El modelo input\_stream}

El modelo input\_stream es un modelo handler que se encarga de manejar el parser de forma de ir leyendo el input e ir insertándolo en el momento correcto de la simulación. Para esto, el modelo está implementado como template de forma de poder funcionar con distintos tipos de inputs, el parámetro template es el mismo que se utiliza para iniciar el parser y tiene las mismas precondiciones. Este modelo envía los mensajes de forma multiplexada con interfaz $0$.\\

Para utilizar este modelo, hay que crear una clase input\_stream\_$<$tipo del input$>$ que herede de input\_stream \footnote{El archivo header siempre tiene que ser de tipo \textit{.h} y la implementación debe estar en un archivo \textit{.cpp}} instanciando el parámetro template del tipo de datos del input. Dado que el simulador PowerDEVS requiere que los modelos tengan un archivo \textit{.cpp} el mismo debe existir y puede simplemente estar vacío. \\

Una vez creada la herencia, el modelo atómico está listo para ser utilizado, el mismo no tiene ningún puerto de entrada y un solo puerto de salida por donde salen los inputs generados, este puerto de salida es el que debe ser conectado al modelo que precisa del input. Un ejemplo de esto se encuentra disponible en el modelo del caso de estudio presentado con el nombre \textit{domain\_name\_source.h}. \\

Los parámetros a setear del mismo en la IDE de PowerDEVS son los que se muestran en la Tabla \ref{table: input stream parameters}.
\begin{table*}[h]
\begin{tabular}{|l|c|c|c|}
  \hline
  \textbf{Nombre} & \textbf{Tipo} & \textbf{Descripción} \\
  \hline
  Module name & String & El nombre del módulo que utiliza el logger \\
  \hline
  Input & String & El path al archivo donde está guardado el input a parsear \\
  \hline
\end{tabular}
\caption{Parámetros del modelo input\_stream}
\label{table: input stream parameters}
\end{table*}

\subsection{El modelo output\_stream}
De la misma forma que es necesario contar con modelos generadores, también se necesita contar con modelos vertederos o \textit{sink} en ingles. Estos modelos sirven para absorver todo el output generado por el modelo y guardarlo en un archivo. Este modelo espera mensaje multiplexados. El mismo está implementado de la misma forma que el modelo input stream y se hereda tomando las mismas consideraciones. Las únicas diferencias son las siguientes: \\

\begin{itemize}
\item No cuenta con ningún puerto de salida y cuenta con un puerto de entrada.
\item Tiene dos tipos de datos template, uno para el tipo de output que le llega por el puerto $0$ y otro para el que le llega por el puerto $1$. Esto es así ya que la arquitectura de capas introducido en este trabajo envía mensajes de tipo datos por el puerto $0$ y mensajes de tipo control por el puerto $1$. Para que el modelo vertedero pueda aceptar ambos mensajes se utilizó este mecanismo.
\end{itemize}

Un ejemplo de esto se encuentra disponible en el modelo del caso de estudio presentado con el nombre \textit{domain\_name\_source.h}. Los parámetros a setear del mismo en la IDE de PowerDEVS son los que se muestran en la Tabla \ref{table: output stream parameters}.
\begin{table*}[h]
\begin{tabular}{|l|c|c|c|}
  \hline
  \textbf{Nombre} & \textbf{Tipo} & \textbf{Descripción} \\
  \hline
  Module name & String & El nombre del módulo que utiliza el logger \\
  \hline
  Output & String & El path al archivo donde está guardado el input a parsear \\
  \hline
\end{tabular}
\caption{Parámetros del modelo input\_stream}
\label{table: output stream parameters}
\end{table*}

\section{Logger}

La clase Logger sirve para ir creando logs de la simulación. Esta clase separa los logs en cuatro tipos:

\begin{itemize}
\item \textbf{LOG:} Logs que sirven para documentar eventos no relevantes de la simulación.
\item \textbf{INFO:} Logs utilizados para documentar eventos relevantes de la simulación.
\item \textbf{DEBUG:} Logs utilizados para documentar eventos que sirven de ayuda para tareas de debug pero que no tiene ningún otro interés.
\item \textbf{ERROR:} Logs utilizados para documentar errores producidos en tiempo de ejecución.
\end{itemize}

Para habilitar y deshabilitar los distintos tipos de logs a guardar en una simulación solo hay que comentar y descomentar las lineas $4,5,6$ y $7$ del archivo \textit{logger.h}, de esta forma en el código se logean todos los eventos correspondientes a estas cuatro categorías y luego antes de cada simulación se decide que mensajes mostrar y cuales no. \\

Lineas a descomentar y comentar para habilitar y deshabilitar los distintos tipos de logs correspondientemente:
\begin{lstlisting}
#define show_log
#define show_info
#define show_debug
#define show_error
\end{lstlisting}

Para utilizar esta clase, cada modulo tiene que crear una variable de tipo \textit{Logger} e inicializarla pasándole como parámetro un \textit{string} con el nombre del módulo o modelo del cual el logger va a loggear eventos y luego utilizarlo siguiendo su interfaz. La inicialización de la variable puede ser en su constructor o mediante el método \textit{Logger::setModuleName(std::string other\_module\_name)}. La documentación de la interfaz está en formato Doxygen. \\

La clase tamplate \textit{Layer}, ya cuenta con una variable de tipo textit{Logger} que debe ser inicializada en el método \textit{init}.

\newpage

\section{Caso de estudio}
	Además de implementar un framework para el estudio de las redes, en este trabajo se introduce un modelo sencillo del protocolo UDP/IP, el mismo cuenta con los protocolos necesarios para que la red funcione de forma que los mensajes van pasando a través de las distintas capas para llegar a ser enviados de un dispositivo a otro. La Figura \ref{figure: protocolos} muestra un diagrama de los protocolos implementados. \\

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.8\textwidth]{img/png/protocols.png}
    \caption{Protocolos implementados separados por capas y dispositivos que los utilizan.}
    \label{figure: protocolos}
\end{figure}

Si bien en la implementación de los procolos de la capa de enlace se van a encontrar similitudes con \textit{Ethernet}, tales como la estructura de datos utilizada para implementar los frames de capa 2 y algunos protocolos utilizados para resolver direcciones, la idea de los modelos de este trabajo no es implementar \textit{Ethernet}. En este trabajo se implementa un protocolo de capa de enlace (al que le daremos el nombre general de protocolo link), que se abstrae de las implementaciones particulares de cualquier protocolo puntual existente.
	
\subsection{DNS (Domain Name System)}
\textit{DNS} (\textit{Domain Name System}) es un sistema de indexación mediante el cual se puede transformar un nombre de dominio en una dirección \textit{IP} del host correspondiente. Este sistema es muy utilizado ya que para los humanos es muy difícil recordar direcciones en formato \textit{IP} pero no en formato \textit{Domian Name}. Asi como el sistema de indexación de una guia telefónica indexa por apellido y nombre para conseguir el número de teléfono de las persona, cuando se cuenta con un nombre de dominio se debe utilizar \textit{DNS} para conseguir la direccion \textit{IP} del host. Este sistema pertenece a la capa de aplicación y es utilizada por diversas aplicaciones para facilitar la comunicación con aplicaciones remotas. Ejemplos de esto son los browsers donde una persona escribe el nombre de dominio de un servidor y \textit{DNS} lo transforma en \textit{IP} para poder acceder al mismo donde se encuentra alojada la plataforma web. 

\newpage

\subsubsection{Estructuras de datos correspondientes}
La estructura de datos utilizada para el sistema de \textit{DNS} es dns::Packet y cuenta con los siguientes campos:
\begin{itemize}
\item \textbf{header: } Es de tipo dns::Header, cuanta entre otras cosas, con toda la información necesaria para saber cuantos dns::ResourceRecord hay en cada una de los siguientes campos. La Figura \ref{figure: dns header} muestra esta estructura de datos.
\item \textbf{questions: } Una lista de dns::ResourceRecord que almacena el nombre de dominio del cual se desea obtener el \textit{IP} asociado.
\item \textbf{answers: } Una lista de dns::ResourceRecord que almacena la respuesta obtenida mediante \textit{DNS}.
\item \textbf{authoritatives: } Una lista de dns::ResourceRecord que almacena la dirección \textit{IP} de servidores \textit{DNS} mediante los cuales se puede obtener la dirección pedida.
\item \textbf{aditionals: } Una lista de dns::ResourceRecord donde se guarda la dirección ip del host que mandó el request. De esta forma no necesita pedirle a la capa \textit{UDP} por el ip que mandó el \textit{request}.
\end{itemize}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.8\textwidth]{img/png/dns-header.png}
    \caption{Estructura del tipo de datos dns::Header alineada a 4 bytes.}
    \label{figure: dns header}
\end{figure}

La Figura \ref{figure: dns header} muestra la estructura del header de un paquete dns, en el mismo se ven los campos \textbf{\textit{QDCount}}, \textbf{\textit{ANCount}}, \textbf{\textit{NSCount}} y \textbf{\textit{ARCount}} que indican la cantidad de dns::ResourceRecords en cada una de las secciones \textbf{\textit{questions}}, \textbf{\textit{answers}}, \textbf{\textit{authoritatives}}, \textbf{\textit{aditionals}} respectivamente. No todos los campos son utilizados en la implementación realizada en este trabajo, la utilización de los mismos será explicada a continuación junto con la explicación del funcionamiento del protocolo. Esta estructura sigue las especificaciones RFC 6895, más información detallada puede ser encontrada en \cite{eastlake2013domain}\\

dns::ResourceRecord es la estructura de datos encargada de guardar información de pares de pregunta/respuesta. Si bien la pregunta es siempre de tipo dns::DomainName, la respuesta puede no siempre ser de tipo \textit{IP}, en algunos casos como en los renombres de dominios, o en las consultas no recursivas, la respuesta puede ser  de tipo dns::DomainName.\\

Los campos de la estructura dns::ResourceRecord son los siguientes:

\begin{itemize}
\item \textbf{name: } Es de tipo dns::DomainName y guarda el nombre de dominio del cual se quiere conocer su \textit{IP}.
\item \textbf{QType: } Indica el tipo de respuesta; A = 1 representa respuestas de servidores autoritativos y son de tipo \textit{IP}, NS = 2 representa redirecciones a un servidor autoritativo para una determinada zona y son de tipo dns::DomainName.
\item \textbf{Avalue: } Si la respuesta es de tipo A, este campo guarda el \textit{IP} correspondiente a la respuesta.
\item \textbf{NSValue: } Si la respuesta es de tipo NS, este campo guarda el dns::DomainName correspondiente a la respuesta.
\item \textbf{QClass: } Este campo indica el protocolo a utilizar; En este trabajo y en la mayoría de los casos, este campo se mantiene siempre con el valor IN = 1 = Internet protocol.
\item \textbf{TTL: } Es el tiempo de vida (generalmente en segundos) utilizado para saber cuanto tiempo se puede mantener un recurso obtenido por un pedido \textit{DNS} en la memoria cache antes de considerar que es invalido y eliminarlo.
\end{itemize}

Por último dns::DomainName es una estructura que sirve para guardar nombres de dominios como por ejemplo ``\textit{network.devs.com}''. El mismo cuenta con métodos que permiten leer, escribir, imprimir y trabajar fácilmente con la jerarquía de zonas de los mismos. Por ejemplo, para saber si un nombre de dominio pertenece a la zona de otro nombre de dominio, Se puede hacer lo siguiente: \\

dns::DomainName(``\textit{com}'').isZoneFor(``\textit{network.devs.com}'').
\subsubsection{Funcionamiento del protocolo}

\paragraph{cliente}
El protocolo implementado en este trabajo para el cliente es muy simple, las consultas comienzan con un dns::Packet que tiene un solo RR (dns::ResourceRecord) en la sección \textit{questions} que contiene el nombre de dominio del cual se desea saber el \textit{IP}. El Protocolo comienza buscando el nombre de dominio del RR en el cache y si lo encuentra devuelve el \textit{IP} asociado y terminó la consulta. En caso de que no lo encuentre los siguientes pasos son realizados:

\begin{enumerate}
\item Le asigna un nuevo ID al dns::Header del dns::Packet de la consulta.
\item Le asigna el valor QR = 1 para indicar que es una query y no un answer.
\item Le asigna el valor RD = 1 para indicar que desea que la consulta se resuelva de forma recursiva, si el servidor no es recursivo este campo será ignorado y enviara una redirección a otro servidor.
\item Guarda el paquete en una tabla de consultas realizadas localmente (i.e. consultas realizadas por el host local).
\item Agrega un RR A la sección \textit{aditionals} que contiene el IP local para que el servidor sepa a quien devolver la respuesta.
\item Envía el paquete al servidor local para que el mismo resuelva el pedido.
\end{enumerate}

\paragraph{Servidor recursivo}
Cuando un servidor recursivo recibe un dns::Packet con el campo QR = 1, el mismo intenta primero resolver la consulta buscando en la tabla de nombres de dominios para los cuales el es autoritativo. envía la respuesta realizando los siguientes pasos:

\begin{enumerate}
\item Al paquete entrante le cambia el campo QR = 0 para indicar que es una respuesta.
\item Asigna el valor AA = 1 para indicar que la respuesta proviene de un servidor autoritativo para ese nombre de dominio.
\item Le agrega un RR en la sección \textit{answers} con \textit{Qtype} = A, con el nombre de dominio de la consulta y en \textit{AValue} el IP correspondiente al nombre de dominio.
\item Envía el dns::Packet de retorno al servidor que envió el \textit{request}, el IP del mismo se encuentra en el RR de la sección \textit{aditional}.
\end{enumerate}

En caso de no encontrar la respuesta en su lista personal, si el paquete dns tiene el campo RD = 1 el servidor realiza los siguientes pasos con la finalidad de conseguir la respuesta mediante otros servidores de forma recursiva:

\begin{enumerate}
\item Guarda el paquete en una tabla de consultas realizadas remotamente (i.e. consultas realizadas por un \textit{host} remoto que llegó a través de paquetes dns).
\item Cambia el RR de la sección \textit{aditionals} para asignarle el \textit{IP} local para que el servidor al cual reenvíe la consulta sepa como enviarle la respuesta.
\item Envía el paquete al servidor TLD (Top Level Domain) que conoce.
\end{enumerate}

Una vez reenviada la consulta se queda a la espera de una respuesta de del servidor. Si el servidor es autoritativo para ese nombre de dominio ó es un servidor recursivo, le enviará una respuesta final con el \textit{IP} correspondiente que será reenviado al \textit{host} del cual llegó la consulta. Si el servidor no es ni autoritativo para la consulta ni recursivo, entonces va a devolver una redirección a un servidor autoritativo para esa zona, cuando esto ocurre, en el paquete dns de respuesta vienen dos RRs, uno en la sección \textit{answers} de tipo NS que contiene el nombre de dominio de dicho servidor y otro en la sección \textit{authoritatives} de tipo A con el \textit{IP} de dicho servidor. En este caso el paquete es reenviado a dicho servidor con la esperanza de que esté resuelva la consulta o vuelva a enviar una redirección. \\

\textbf{Note:} El \textit{IP} de dicho \textit{host} está en el paquete dns que se guardó anteriormente, y la forma de recuperarlo es utilizando el ID de la consulta que se mantiene igual durante todo el proceso. \\

\textbf{Note:} En caso de que el servidor envíe un paquete dns de error, el mismo es reenviado al \textit{host} que realizo la consulta y el protocolo falló. Esto puede ocurrir porque no se conoce de ningún servidor autoritativo para la zona del nombre de dominio consultado. \\

\textbf{Note:} El paquete enviado como respuesta final es un paquete que llega desde un servidor al cual se le realizó la consulta, y por ende el campo AA que indica si la respuesta es autoritativa o no, depende de dicho servidor. \\

En caso de que que el campo RD esté en 0, el servidor se comporta como un servidor iterativo \\

\paragraph{Servidor iterativo}

Cuando una consulta llega a un servidor iterativo, en caso de ser autoritativo para la consulta, envía el paquete previamente transformado en respuesta con el \textit{IP} correspondiente a la consulta asignando AA = 1 y termina. En caso de no ser autoritativo, el servidor busca en la tabla de \textit{DN servers} un servidor que sea autoritativo para la zona del nombre de dominio consultado, en caso de haber más de uno, elige el servidor más puntual y lo envía como respuesta de redirección. Para esto realiza los siguientes pasos modificando el paquete de la consulta para mantener el ID correcto.

\begin{enumerate}
\item Agrega un RR de tipo NS en la sección \textit{answers} donde \textit{name} contiene el nombre de dominio para el cual el servidor es responsable de todos sus sub-dominios (i.e. es responsable de esa zona), y en \textit{NSValue} el nombre de dominio del servidor.
\item Agrega un RR de tipo A en la sección \textit{authoritatives} donde \textit{name} es igual al campo \textit{NSValue} del RR mencionado en el punto anterior y en el campo \textit{AValue} el \textit{IP} de dicho servidor.
\item Asigna AA = 0 para marcar que el no es autoritativo para dicha consulta.
\item Utiliza el RR de la sección \textit{aditionals} para enviar el paquete con la respuesta al host que realizó la consulta.
\end{enumerate}

\textbf{note: } un servidor $s1$ es más puntual para una zona que otro servidor $s2$ si y solo si $s1$ pertenece a la zona de $s2$, por ejemplo ``devs.com'' es más puntual que ``com'' ya que ``devs.com'' pertenece a la zona ``com'', con lo cual, si hay una consulta ``algo.devs.com'' el servidor que tiene la respuesta final es ``devs.com'' y no ``com'' quien va a devolver una redirección a ``devs.com''.

\newpage

\subsection{UDP (User Datagram Protocol)}

\subsubsection{Estructuras de datos correspondiente a UDP}

El protocolo UDP implementado cuenta con los siguientes tipos de datos, los cuales tienen documentación en formato Doxygen en el código y que se encuentra adjunta en el apéndice de este documento:

\begin{itemize}
\item udp::Segment: Representa un segmento de datos para ser enviado por la red, el mismo cuenta con pseudoheader, header y payload como se muestra en la Figura \ref{figure: udp segment}. Esta estructura de datos sigue el esquema marcado en RFC 768 \cite{postel1980user}.
\item udp::Control: Es la estructura de datos utilizada para la comunicación con la capa de aplicación, en la misma se especifica que comando envía la aplicación a la capa UDP. Toda la información a enviar llega al protocolo UDP a través de esta estructura.
\end{itemize}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.7\textwidth]{img/png/UDP-Segment.png}
    \caption{Estructura del tipo de datos udp::Segment alineada a 4 bytes.}
    \label{figure: udp segment}
\end{figure}

\subsubsection{Comportamiento del protocolo}

El protocolo UDP no cuenta con ningún sistema de detección de fallas en la entrega de los mensajes ya que el mismo está pensado para funcionar de forma que optimice la velocidad de entrega, para esto se basa en un mecanismo de mejor esfuerzo. Esto lo convierte en un buen protocolo cuando la eficiencia es un atributo clave. Por otro lado, dado que no controla que los mensajes lleguen o no a su destino, es necesario contar con otro mecanismo que detecte mensajes faltantes (aquellos que no llegaron a destino) o de lo contrario, debe permitirse la perdida de los mismos. Si bien no se realiza ningún esfuerzo por detectar si el mensaje llega o no a destino, UDP implementa checksum para detectar errores en la codificación del header del segmento, esto es implementado con la finalidad de no entregar mensajes a destinatarios incorrectos. Cuando un error es detectado en el header, el segment es directamente descartado\footnote{No se comprueba que el payload contenga errores en su codificación, por lo que el dato en si, podría llegar a destino con errores y nunca serían detectados por UDP.}.\\

UDP funciona con sockets, los sockets son una combinación de IP y puerto que permiten enviar y entregar los mensajes a la aplicación correspondiente dentro del host de destino. De esta forma, para que un mensaje sea correctamente entregado, el host destino tiene que tener una aplicación que esté escuchando por el puerto al cual fue enviado el mensaje, si este no es el caso, el mensaje es simplemente descartado. Los sockets también cumplen en este trabajo el roll de evitar colisiones entre las aplicaciones ya que las mismas no pueden unirse a un puerto mediante un socket si el puerto ya está siendo utilizado por otra aplicación, ya sea para enviar o recibir mensajes. Esta decisión de no permitir a dos aplicaciones utilizar un mismo socket a la misma vez no es general de UDP y es más bien particular de esta implementación, futuros trabajos podrían implementar un protocolo sin este comportamiento. La Figura \ref{figure: UPD state machine} muestra la máquina de estados del protocolo UDP implementado en este trabajo. \\

\begin{figure}[t]
    \centering
    \includegraphics[width = 0.7\textwidth]{img/png/UDP-state-machine.png}
    \caption{Máquina de estados del protocolo UDP para un socket determinado. Por prolijidad, el comando \textit{CLOSE} no aparece, el mismo corta cualquier estado y vuelve automáticamente a \textit{LIBRE}.}
    \label{figure: UPD state machine}
\end{figure}

\newpage
 
En el modelo implementado, los mensajes de Control contienen un campo \textit{request} que indica que operación se desea efectuar (connect, bind, read, etc) también es necesario enviar el IP y puerto del socket y el id de la aplicación, esta información es siempre requerida, ya sea para crear un nuevo socket atado a la aplicación del id o para corroborar que el socket existe y que corresponde a la aplicación que envía el mensaje de control. Dependiendo de la operación, es preciso completar correctamente los campos restantes. A continuación se explica cada operación y que campos requiere cada una: \\

\begin{itemize}
\item \textbf{CONNECT}: \textit{remote\_ip}, \textit{remote\_port}. De está forma UDP sabe que cada vez que esta aplicación envíe o reciba un paquete, el mismo será para o desde el socket remoto con IP \textit{remote\_ip} y puerto \textit{remote\_port}. Esta operación falla si el socket ya existe por lo explicado previamente. \textbf{Nota:} Este comando solo sirve (al igual que BIND), para unirse a un socket dentro del protocolo, pero no hay ningún tipo de conexión remota ni \textit{handshake} realizado ya que UDP es \textit{connectionless}.
\item \textbf{BIND:} Esto permite a la aplicación enviar paquetes a distintos destinos, especificando siempre el socket del destino (socket remoto) mediante los comandos WRITE\_TO y SEND\_TO y recibir mensajes de distintos orígenes mediante los comandos READ\_FROM, RECV\_FROM, REC o READ. Esta aplicación falla si el soquet ya existe.
\item \textbf{READ\_FROM / RECV\_FROM:} \textit{remote\_ip}, \textit{remote\_port}, estos campos son utilizados para saber que mensajes entrantes deben que ser aceptados y cuales no. Cuando este comando es recibido por UDP, el socket correspondiente es marcado como ``En espera de mensajes'' y el mismo se mantiene en ese estado hasta que llega un mensaje del host remoto indicado, en ese momento el mensaje es entregado y el socket vuelve al estado anterior. Este comando solo puede ser utilizado en un socket que está en estado \textit{BOUND}, o sea, un socket que fue previamente bindeado.
\item \textbf{READ / RECV:} Es lo mismo que el item anterior pero con la diferencia de que no se especifica un socket remoto. Si el el soket local fue bindeado se aceptan todos los mensajes entrantes a este socket y si fue conectado se aceptan solo los mensajes del socket remoto indicado en el momento de la conexión.
\item \textbf{WRITE\_TO / SEND\_TO:} Lo mismo que READ\_FROM / RECV\_FROM pero para enviar mensajes, con lo cual el campo \textit{packet} debe contener el paquete a enviar.
\item \textbf{WRITE / SEND:} Lo mismo que READ / RECV pero para enviar mensajes, con lo cual el campo \textit{packet} debe contener el paquete a enviar.
\item \textbf{CLOSE:} Esta operación remueve el socket, dejando el IP y puerto libres para futuras aplicaciones que quieran conectarse o bindearse al mismo.
\end{itemize}

Cada vez que el protocolo UDP quiere enviar un paquete, crea un nuevo udp::Segment, asigna el paquete en el campo \textit{payload} en formato \textit{char *} de no más de $512$ bytes de tamaño, completa los campos correspondientes del header y pseudoheader, calcula el checksum utilizando el header ya completado, guarda el valor obtenido en el campo \textit{checksum} y envía el mensaje a la capa inferior por el canal de datos encolando el mismo en la cola \textit{lower\_layer\_data\_out}. \\

Cada vez que el protocolo UDP recibe un mensaje de la capa inferior se realizan un par de chequeos, en caso de que el mensaje pase los controles, el \textit{payload} del segmento recibido es entregado a la aplicación correspondiente, en caso contrario el segmento es descartado. Un segmento pasa los chequeos si se cumplen las siguientes condiciones:

\begin{itemize}
\item El campo \textit{checksum} debe coincidir con el calculo de checksum que realiza nuevamente el protocolo sobre el header del segmento recibido.
\item El socket destino del segmento debe ser un socket local existente.
\item El socket local debe estar en un estado de ``En espera de mensajes''.
\item El socket local debe estar esperando mensajes del socket remoto o esperando mensajes de cualquiero socket remoto.
\end{itemize}

La estructura de datos \textit{Socket} es utilizada para manipular esta combinaciones de ip-puerto, la misma cuenta con los siguientes campos.

\begin{itemize}
\item \textbf{local\_port: } Es de tipo \textit{uint\_16} y representa el puerto del host local al cual se conecta o bindea el socket.
\item \textbf{remote\_port: } Es de tipo \textit{uint\_16} y representa el puerto del host remoto al cual se desea enviar y/o recibir datos. Este campo es opcional, no siempre se especifica un host remoto, por ejemplo, cuando se desea leer datos de cualquier host remoto, este campo no debe especificarse.
\item \textbf{local\_ip: } Es de tipo \textit{IPv4}\footnote{El tipo de datos \textit{IPv4} está documentado en formato Doxygen en el código} y representa el ip del host local al cual se conecta o bindea el socket.
\item \textbf{remote\_ip: } Es de tipo \textit{IPv4} y representa el ip del host remoto al cual se desea enviar y/o recibir datos. Este campo es opcional, no siempre se especifica un host remoto, por ejemplo, cuando se desea leer datos de cualquier host remoto, este campo no debe especificarse.
\item \textbf{status: } Es de tipo enum e indica en que estado se encuentra el socket. Los estados son los mencionados previamente cuando se explicaron los comandos.
\end{itemize}

La Tabla \ref{table: parameters UDP} muestra los parámetros del modelo UDP en la IDE PowerDEVS.
\begin{table*}[h]
\begin{tabular}{|l|c|c|c|}
  \hline
  \textbf{Nombre} & \textbf{Tipo} & \textbf{Descripción} \\
  \hline
  Module name & String & El nombre del módulo que utiliza el logger \\
  \hline
  ip\_amount & Int & La cantidad de ip locales, generalmente este valor es 1 \\
  \hline
  ip 1 & IPv4 & La primer ip local \\
  \hline
  \vdots & \vdots & \vdots \\
  \hline
  ip n & IPv4 & La última ip local \\
  \hline
\end{tabular}
\caption{Parámetros del modelo UDP}
\label{table: parameters UDP}
\end{table*}

\subsection{IP (Internet Protocol)}

El protocolo IP es el encargado del enrutamiento de los ip::Datagrams de un nodo (router, host) a otro con la finalidad de llegar al host destino. La estructura de datos ip::Datagram es la utilizada para encapsular los udp::Segments y cuenta con un campo \textit{header} de tipo ip::Header y un campo \textit{data} de tipo udp::Segment, la Figura \ref{figure: ip header} muestra la estructura del tipo de datos ip::Header. Tanto la estructura del ip::Header como los algoritmos implementados para el protocolo IP de este trabajo están basados en los protocolos explicados en \cite{routingtablemicrosoft} y \cite{routingprocessmicrosoft} \\

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.4\textwidth]{img/png/IP-datagram.png}
    \caption{Estructura del tipo de datos de ip::Header alineada a 4 bytes.}
    \label{figure: ip header}
\end{figure}

El protocolo IP implementado en este trabajo funciona con segmentos UDP pero puede muy facilmente ser extendido para aceptar segmentos de otros protocolos como por ejemplo TCP. El protocolo IP implementado en este trabajo se puede dividir en dos categorías:
\begin{itemize}
\item \textbf{Enrutamiento en un host:} Los hosts son los encargados de encapsular los udp::Segments provenientes de la capa superior (UDP) dentro de ip::Datagrams y enviarlos al router o host directamente conectado al mismo dependiendo de si el IP de destino corresponde a un un host de la misma subnet o a un host en otra subnet. Si un host recibe un ip::Datagram cuyo IP destino no corresponde con ningún IP del host, el ip::Datagram no es forwardeado a nadie y es descartado, en cambio si el IP corresponde con algún IP del host, el udp::Segment del ip::Datagram recibido es desencapsulado y entregado a la capa superior.
\item \textbf{Enrutamiento en un router:} Los routers por el contrario no encapsulan udp::Segments ya que no existe capa de transporte en un router, los mismos se encargan de forwardear ip::Datagrams que llegan.
\end{itemize}

Si bien hay diferencias entre los hosts y los routers, el proceso de forwardear ip::Datagrams es el mismo para ambos, este proceso consiste en buscar el mejor \textit{nexthop} dentro de la ``routing table'' y enviar el ip::Datagram al mismo con la esperanza de que este sepa como entregar el mensaje al destino. Es por esta igualdad, que se implemento una clase \textit{ip\_protocol} general que modela el comportamiento común entre el protocolo IP de un host y de un router y luego se extendió dicho modelo a dos modelos más especificos, uno para el protocolo IP de un host y otro para el modelo IP de un router.\\

En este trabajo no se implementaron clases de direcciones IP A, B y C, por el contrario se implementó el mecanismo de \textit{subneting} mediante el uso de \textit{netmasks}, esto significa que se utiliza una máscara que indica cuantos bits de la izquierda del IP corresponden al network. La máscara utilizada es una dirección IP que tiene en los bits de la izquierda unos y en los bits de la derecha ceros, la cantidad de unos de la máscara determinan cuantos bits del IP deben ser considerados como network. Más información sobre este mecanismo puede ser encontrado en la sección \textit{Subnetting and classless addressing} en el libro de la materia \cite[p.~220]{peterson2011computer}. \\

La routing table contiene los siguientes campos:
\begin{itemize}
\item \textbf{Network:} IP del network asociado a esta entrada.
\item \textbf{Netmask:} Máscara utilizada para saber qué parte del Network debe ser comparado con el IP destino para determinar si el IP destino corresponde a la misma red a la cual se puede llegar mediante este nexthop.
\item \textbf{nexthop:} IP del nodo al cual hay que enviarle el ip::Datagram de forma que el mismo sepa como entregar el ip::Datagram. El nexthop debe estar directamente conectado con el nodo actual. El mismo puede ser un host, en este caso, el destino es directamente alcanzable y el mensaje es enviado al mismo.
\item \textbf{Metric:} Una métrica de distancia (en términos de nodos intermedios) a la cual se encuentra el destino del router o host actual.
\item \textbf{Description:} Una descripción que ayude a comprender el rol del nexthop. Esto puede ser el nombre del mismo.
\end{itemize}

Para determinar cual \textit{nexthop} es el mejor se utiliza el siguiente criterio: Se elige aquel nexthop con prefijo de network más pequeño, si hay más de uno con menor prefijo, se elige aquel con menor métrica, o sea, aquel para el cual se espera que el camino sea menor, si sigue siendo necesario desempatar, se elige el primero de la tabla de arriba para abajo. \\

Un dispositivo puede tener más de una interfaz, cada interfaz está conectada con una network particular y el \textit{nexthop} elegido pertenece a alguna de esas networks, para saber por que interfaz enviar el ip::Datagram se utiliza la \textit{forwarding table} la cual indica para cada \textit{nexthop} su interfaz asociada dependiendo de en que network se encuentre el \textit{nexthop}. \\

Dado que en este trabajo no se implementó ningún algoritmo dinámico para completar las \textit{routing table} y \textit{forwarding table}, si las mismas no son correctamente inicializadas a mano, puede suceder que un paquete nunca llegue a destino o que el mismo se quede dando vueltas en círculos. Para evitar que se generen ciclos infinitos que ocasionarían una gran congestión de la red, se utiliza el campo \textit{TTL} (Time To Live) el cual arranca con el valor $255$ cuando el host envía el paquete al primer \textit{nexthop} y es decrementado en uno cada vez que pasa por un nuevo router, de esta forma, cuando el \textit{TTL} llega a $0$ el ip::Datagram es descartado en vez de ser forwardeado. Este tipo de problemas puede suceder también cuando las \textit{routing tables} son completadas dinámicamente. \\

Para poder enviar un ip::Datagram al nexthop o al host en cuestión, el protocolo IP le manda un mensaje de control a la capa de linkeo para pedirle que prepare la MAC address asociada al IP del \textit{nexthop}, una vez que recibe el mensaje de la capa de linkeo confirmando que dicha MAC address está cacheada, el protocolo IP pasa el ip::Datagram a la capa de linkeo para que el mismo lo envíe. El mensaje de confirmación de que la \textit{MAC address} existe no asegura que el mensaje sea enviado, en caso de que un error acontezca en el protocolo ARP, el mismo se lo comunica a IP que se queda esperando una nueva confirmación del protocolo ARP comunicando que el envío puede ser realizado. \\

Los parámetros del modelo IP en la IDE de PowerDEVS son los que muestra la Tabla \ref{table: parameters ip}

\begin{table*}[h]
\begin{tabular}{|l|c|c|c|}
  \hline
  \textbf{Nombre} & \textbf{Tipo} & \textbf{Descripción} \\
  \hline
  Module name & String & El nombre del módulo que utiliza el logger \\
  \hline
  ip\_amount & Int & La cantidad de ip locales, generalmente este valor es 1 \\
  \hline
  ip 1 & IPv4 & La primer ip del host \\
  \hline
  \vdots & \vdots & \vdots \\
  \hline
  ip n & IPv4 & La última ip del host \\
  \hline
  file\_path\_rt & String & Path al archivo que contiene las entradas de la routing table \\
  \hline
  file\_path\_ft & String & Path al archivo que contiene las entradas de la fowarding table \\
  \hline
\end{tabular}
\caption{Parámetros del modelo IP}
\label{table: parameters ip}
\end{table*}

\subsection{ARP (Address Resolution Protocol)}

Si bien los IPs cuentan con una estructura jerárquica que permite describir la topología de la red y de esa forma agrupar a los hosts por networks, los mismos son asignados dinámicamente dependiendo de en donde está conectado el host. Por el contrario, las \textit{MAC addresses} son fijas, y cada dispositivo de red viene con una \textit{MAC address} de fábrica, la misma se supone que es única. Para poder enviar datos de un dispositivo a otro, es necesario primero conseguir su \textit{MAC address}, el protocolo ARP (\textit{Address Resolution Protocol}) es el encargado en este modelo para realizar este trabajo. Más información sobre ARP pude ser encontrada en la sección \textit{Address Translation (ARP)} del libro de la materia \cite[p.~228]{peterson2011computer} y en el RFC 826 \cite{plummer1982ethernet}. Vale aclarar que este trabajo implementó una versión más cercana al libro de la materia.\\

Los ip::Datagram que deben ser enviados entre dos nodos adyacentes de la red son encapsulados dentro de un link::Frame, el cual cuenta con la estructura mostrada en la Figura \ref{figure: frame structure}. Esta estructura proviene del estandar para ethernet II. \\

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.9\textwidth]{img/png/l2-frame.png}
    \caption{Estructura de datos de un link::Frame.}
    \label{figure: frame structure}
\end{figure}

El campo payload es el que contiene al ip::Datagram, el mismo admite un tamaño máximo de $1500$ bytes, por lo cual todos los paquetes enviados en este modelo deben tener un tamaño menor a $1500$ bytes \footnote{En este trabajo no está implementado el mecanismo de fragmentación}. El campo \textit{MAC\_destination} es el que contiene el \textit{MAC address} del dispositivo de destino al cual se desea enviar el frame.\\

El protocolo ARP cuenta con una \textit{ARP table}, la cual tiene las siguientes columnas:

\begin{itemize}
\item \textbf{ip:} El IP del dispositivo al cual se debe enviar el link::Frame, este IP es el que utiliza la capa IP.
\item \textbf{mac:} La \textit{MAC address} del dispositivo al cual se debe enviar el link::Frame.
\item \textbf{timeout:} Es el periodo de tiempo de validez que tiene el dato. Cada vez que se agrega una fila a la \textit{ARP table}, al mismo se le asigna un \textit{timeout}, y cuando el mismo se acaba, la fila es eliminada de la tabla.
\end{itemize}

Cada vez que el protocolo IP envía un pedido para enviar un ip::Datagram, el protocolo ARP busca el IP en la \textit{ARP Table}, si hay una entrada con ese IP, ARP manda un mensaje de control a la capa IP comunicando que el envío puede ser efectuado, si por el contrario, no hay una entrada con ese IP, ARP envía un link::arp::Packet con un pedido de \textit{MAC} a todos los dispositivos de la red directamente conectados con el. Todo dispositivo que recibe un link::arp::Packet con pedido de \textit{MAC} cuya dirección IP corresponda con la requerida, enviará una respuesta con su \textit{MAC address}, luego, el dispositivo que envió el pedido, al recibir la respuesta agrega la nueva entrada a la \textit{ARP table}. Una vez que se obtuvo la \textit{MAC address}, ARP envía el mensaje de control a la capa IP comunicando que el envío puede ser efectuado. Si ningún dispositivo de la red matchea con el IP solicitado, entonces el ip::Datagram nunca será enviado pues el protocolo ARP se quedará hasta el infinito esperando la respuesta de la red, esto no implica que el protocolo quede bloqueado y otros pedidos podrían ser procesados.\\

Podría suceder que durante el tiempo que transcurre entre que ARP envía el mensaje a IP comunicándole que el envío puede realizarse y que el protocolo IP manda el ip::Datagram para ser enviado, el \textit{timeout} de la \textit{MAC address} requerida se cumpla y la misma sea eliminada de la tabla. Si este es el caso, se envía un mensaje al protocolo IP de falla en el envío del ip::Datagram y se vuelve a mandar un link::arp::Packet para volver a obtener el \textit{MAC address}. La figura \ref{figure: ARP IP comunication flow} muestra la comunicación entre ARP y IP para la obtención de la \textit{MAC address} y la Figura \ref{figure: arp packet} muestra la estructura de un link::arp::Packet.\\

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.9\textwidth]{img/png/ip-arp-comunication.png}
    \caption{Flujo de comunicación entre los protocolos IP y ARP para enviar un ip::Datagram.}
    \label{figure: ARP IP comunication flow}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.6\textwidth]{img/png/arp-packet.png}
    \caption{Estructura de datos de un link::arp::Packet alineada a 4 bytes. \textbf{Nota:} las direcciones de hardware (\textit{MAC addresses}) son de 6 bytes y no de 4, esto no se muestra en la figura para mantener el orden de los campos. Más información puede ser encontrado en el RFC 826 \cite{plummer1982ethernet}}
    \label{figure: arp packet}
\end{figure}


Un dispositivo puede tener varias interfaces físicas y cada interfaz es un modelo atómico distinto del protocolo\textit{Link} que implenta ARP y SWL. Este es el caso de los routers que cuentan con una interfaz por cada network al que están conectados. Cada interfaz cuanta con un IP y con una \textit{MAC address} y los pedidos de \textit{MAC address} que llegan a la interfaz son respondidos por el protocolo ARP dentro de la interfaz sin llegar a la capa de enrutamiento. De esta forma, un router puede ser accedido por los dispositivos de una red solo si ellos conocen el IP de la interfaz que está conectada a dicha red, en caso de que llegue un pedido de \textit{MAC address} para un IP de otra interfaz, el mismo es ignorado ya que las interfaces son independientes entre si. \\

Tanto \textit{ARP} como \textit{SWP} (explicado más adelante) son protocolos de nivel 2 y es por eso que se encuentran ambos implementados dentro del modelo \textit{link}. La tabla \ref{table: parameters link} muestra los parámetros del modelo de \textit{link} en la IDE PowerDEVS. 

\begin{table*}[h]
\begin{tabular}{|l|c|c|c|}
  \hline
  \textbf{Nombre} & \textbf{Tipo} & \textbf{Descripción} \\
  \hline
  Module name & String & El nombre del módulo que utiliza el logger \\
  \hline
  Mac & MAC & la mac address de la interfaz \\
  \hline
  ip & IPv4 & La ip de la interfaz \\
  \hline
  interface & Int & El número de la interfaz \\
  \hline
\end{tabular}
\caption{Parametros del modelo Link}
\label{table: parameters link}
\end{table*}

\subsection{Datagrams}
El protocolo Datagrams es utilizado por los switches para forwardear mensajes. El mismo está basado en la sección \textit{Datagrams} del libro de la materia \cite[p.~172]{peterson2011computer} \\

En el modelo implementado, el envío de frames sucede mediante cables ethernet, y para evitar colisiones, un dispositivo puede estar conectado a muchos otros mediante el uso de switches. Aunque en la realidad los switches evitan gran parte de las colisiones, los mismos no evitan todas, ya que siguen existiendo las colisiones generadas entre los frames que se envían de cada punta del cable. Este tipo de colisiones no están consideradas y el modelo implementado se abstrae de ellas, dejándolo como posible trabajo futuro. \\

El trabajo principal de un switch es el de forwardear frames que llegan por un puerto de entrada a través de un puerto de salida de forma de que el frame llegue al destinatario. Para realizar esta tarea, el protocolo implementado es \textit{Datagrams} explicado en el libro de cabecera de la cátedra \cite[p.~172]{peterson2011computer}. El mismo tiene un funcionamiento muy sencillo, utiliza una \textit{forwarding table} que contiene las siguientes columnas: \\

\begin{itemize}
\item \textbf{mac: } La \textit{MAC address} del destinatario.
\item \textbf{interface: } La interfaz o puerto por donde debe forwardear el frame para llegar al destinatario.
\end{itemize}

Cada vez que un nuevo frame llega a un switch, el mismo busca la \textit{MAC address} del destinatario en la \textit{forwarding table} y envía el frame por el puerto correspondiente a esa \textit{MAC address}. Si dicha \textit{MAC address} no está en la \textit{forwarding table}, el frame es descartado y se logea un mensaje de error. \\

Nuevamente, en este trabajo no se implementó ningún algoritmo dinámico para completar las \textit{forwarding tables} de los switches y las mismas deben ser completadas a mano, si dichas tablas no están completas o están mal completadas los frames podrían nunca llegar a destino y/o quedarse dando vueltas entre los distintos switches infinitamente. \\

Tanto \textit{Datagrams} como \textit{SWP} (explicado más adelante) son protocolos de nivel 2 y es por eso que se encuentran ambos implementados dentro del modelo \textit{switch}. La Tabla \ref{table: parameters datagrams} muestra los parámetros del modelo \textit{switch}.

\begin{table*}[h]
\begin{tabular}{|l|c|c|c|}
  \hline
  \textbf{Nombre} & \textbf{Tipo} & \textbf{Descripción} \\
  \hline
  Module name & String & El nombre del módulo que utiliza el logger \\
  \hline
  Interface\_amount & Int & La cantidad de interfaces por las cuales forwardear los Frames entrantes \\
  \hline
  forwarding\_table & String & Path al archivo que contiene las entradas de la fowarding table \\
  \hline
\end{tabular}
\caption{Parámetros del modelo Switch}
\label{table: parameters datagrams}
\end{table*}

\subsection{SWP (Sliding Window Protocol)}

Este protocolo es el utilizado en la capa $2$ y el mismo se encuentra tanto en el modelo \textit{link} como en el modelo \textit{switch}, de esta forma la comunicación de todos los dispositivos a nivel $2$ es realizada mediante \textit{SWP}.\\

En este trabajo también se implementó el protocolo \textit{Sliding Window Protocol} de forma de garantizar que la comunicación entre dos dispositivos de la red se realiza sin perdida de frames y que los mismos llegan en orden, o sea, si se envía más de un paquete de un dispositivo a otro, los mismos son entregados en el mismo orden en que fueron enviados. Para no desaprovechar el ancho de banda enviando un solo frame por vez, el protocolo SWP utiliza una ventana que sirve para marcar cuantos frames pueden ser enviados en simultaneo de forma desordenada y a medida que los mismos van llegando, cuando el destinatario los ordena, la ventana se va corriendo. La Figura \ref{figure: swp timeline} ilustra la idea general del envío y recivo de mensajes mediante el protocolo SWP en una linea temporal.\\

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.3\textwidth]{img/png/swp-timeline.png}
    \caption{Idea general de la linea temporal del protocolo SWP.}
    \label{figure: swp timeline}
\end{figure}

El protocolo SWP está separado en dos partes, el remitente y el destinatario y funcionan de la siguiente manera:

\subsubsection{Remitente:}
Cuenta con una variable \texttt{SWS} (\textit{Send Window Size}) que indica el tamaño de la ventana y una variable \texttt{LAR} \textit{Last Acknowledgment Received} que indica el último frame enviado para el cual se recibió un acknowledgment. A medida que llegan frames a enviar, se les asigna un número de secuencia (\textit{SeqNum}) correspondiente al orden de llegada y se procede a enviar todos aquellos que cumplen que \texttt{LAR} $<$ \textit{SeqNum} $\leq$ \texttt{LAR} + \texttt{SWS}. Por otro lado, cada vez que recibe un ack, mira el \textit{SeqNum} asociado al mismo y corre el inicio de la ventana (la variable \texttt{LAR}) hasta el mismo, esto automáticamente corre el final de la ventana y habilita por lo tanto nuevos frames a ser enviados. Este mecanismo funciona porque se sabe que el destinatario solo envía el ack de un frame cuando todos los frames anteriores al mismo también fueron correctamente recibidos. Cada vez que un frame es enviado, el mismo es guardado en un arreglo de frames enviados esperando que llegue un ack igual o más grande que el mismo, cuando el ack llega, el frame es descartado. Además, todo frame que es enviado se le asigna un timeout, si no se recibe un ack válido para dicho frame antes de que se termine el timeout, se considera que hubo una falla en el envío y el frame es enviado nuevamente.

\subsubsection{Destinatario:}
Cuenta con una variable \texttt{RWS} (\textit{Receive Window Size}) que indica el tamaño de la ventana de cuales \textit{SeqNum} son aceptados y con una variable \texttt{LFR} (\textit{Last Frame received}) que indica el último frame para el cual envió un acknoledgment y por ende el comienzo de la ventana. En caso de que un frame llegue y no cumpla que \texttt{LFR} $<$ \textit{SeqNum} $\leq$ \texttt{LFR} + \texttt{RWS}, el mismo es descartado. Los frames que llegan y son aceptados se guardan en un arreglo a la espera de ser entregados a la capa superior. Cada vez que un frame es aceptado, se mira cual es el frame aceptados con \textit{SewNum} más grande tal que todos los frames con \textit{SeqNum} menor a el ya fueron recibidos y se envía un ack de dicho frame. Una vez que se envió el ack de un frame, el y todos los frames anteriores son enviados a la capa superior. \\

Una cosa a tener en cuenta es que el \textit{SeqNum} está representado con un unsigned char y cuando llega al máximo número representable la secuencia vuelve a empezar de cero. Para evitar problemas con esto, es necesario asegurarse que las ventanas \texttt{SWS} y \texttt{RWS} sean lo suficientemente chicas respecto al máximo \textit{SeqNum} de forma de que cuando se llegue al mismo y se vuelva a empezar no se generen confusiones. \\

\subsection{Tests de unidad}

para tener una validación del comportamiento de cada uno de los módulos del modelo implementado, se realizaron distintos test de unidad, en los cuales se inventó el input de los modelos y se comparó el resultado obtenido con el esperado. De esta forma a continuación se listan todos los test unitarios implementados: \\

El único módulo que no cuenta con test de unidad, es el modelo \textit{Switch} ya que el mismo se encuentra en un modelo acoplado de dispositivo donde es el único módulo, con lo cuál, el test de integración para este caso funciona como test de unidad también. \\

Para realizar test de unidad de cada módulo por separado (un módulo representa una capa o un protocolo en específico), dado que los mismos funcionan en su totalidad mediante la interacción con el resto de los modelos y ellos no van a estar en el test (por ser de unidad y no de integración), se implementaron múltiples modelos generadores y vertederos utilizando la técnica descripta en la Sección \ref{section: I/O}. De esta forma, por cada puerto de entrada por el cual el modelo recibe un input o emite un output desde y hacia otros modelos, se mockean los inputs y se guardan en archivos los output generados por el modelo consiguiendo de esta forma emular un símulación con interacciones aunque no esten todas las partes presentes. \\

\textbf{Nota:} En todos los escenarios realizados para los test de unidad, los paquetes utilizados, son paquetes vacios.\\

\subsubsection{Test de unidad para el módulo DNS}

En el caso del modelo DNS, el test de unidad básico implementado recibe un pedido de resolución para el dominio ``networks.devs.com'' por el puerto de entrada 0 (puerto por el cual recibe datos de la capa superior) en el tiempo virtual 15, el módulo envía un pedido recursivo a su servidor local con ip conocido 1.0.0.2 por el puerto de salida 3 y luego de que el servidor resuelve la consulta de forma recursiva, se le envía un mensaje con la respuesta en formato de paquete dns por el puerto de entrada 2 (puerto por el cual recibe datos de la capa inferior), el mismo procesa la respuesta y la reenvía por el puerto de salido 0. La Figura \ref{figure: unit test dns} muestra el modelo implementado en PowerDEVS para el test de unidad del modelo dns con sus respectivas fuentes y vertederos.

\begin{figure}[!h]
    \centering
    \includegraphics[width = 0.4\textwidth]{img/png/unit_tests/dns.png}
    \caption{Src 1 genera input de tipo dns::DomainName, src 2 genera input de tipo dns::Packet. Sink 1 imprime output de tipo dns::Packet y Sink 2 imprime output de tipo udp::Control, Sinks 3 y 4 imprimen el input generado por Src 1 y Src 2.}
    \label{figure: unit test dns}
\end{figure}

El input y output del test se puede ver en el apendice \ref{appendix: dns unit test}

\newpage

\subsubsection{Tet de unidad para el módulo UDP}

Para testear el módulo UDP se utilizó la misma lógica que para DNS. En este caso, se implementaron generadores tanto para los controles de udp que envían pedidos de conexión, bindeo, etc. desde la capa superior, como para los udp::Segment que llegan desde la capa inferior. La figura \ref{figure: unit test udp} muestra el modelo implementado en PowerDEVS para el test de unidad del módulo UDP. \\

En este escenario, se simuló lo siguiente:
\begin{enumerate}
\item El módulo de capa de aplicación se conecta la aplicación con id 0 al socket local 1.0.0.1:80 y remoto 1.0.0.2:80.
\item El módulo de capa de aplicación realiza envía dos paquetes vacíos para la aplicación con id 0 utilizando el socket previamente conectado.
\item El módulo de capa de aplicación bindea la aplicación con id 1 al socket local 1.0.0.1:8080.
\item El módulo de capa de aplicación envía un paquete para la aplicación con id 1 especificando el destinatario con socket remoto 1.0.0.2:8080.
\item El módulo de capa de aplicación envía un paquete para la aplicación con id 0 por el socket local 1.0.0.1:53 inexistente, por lo que este pedido falla.
\item Una aplicación remota envía un paquete con socket remoto 1.0.0.2:80 y local 1.0.0.1:80. Si bien el socket es válido, el udp::Segment entrante falla en el checksum ya que el mismo es inválido y es descartado (esto no se ve en el output, pero se ve en el log de la simulación).
\end{enumerate}

\begin{figure}[!h]
    \centering
    \includegraphics[width = 0.45\textwidth]{img/png/unit_tests/udp.png}
    \caption{Src 1 genera input de tipo udp::control, src 2 genera input de tipo udp::Segment. Sink 1 imprime output de tipo udp::Control, Sinks 2 imprime output de tipo udp::Segment mientras que Sink 3 y 4 imprimen el input generado por Src 1 y Src 2.}
    \label{figure: unit test udp}
\end{figure}

El input y output del test se puede ver en el apendice \ref{appendix: udp unit test}

\newpage

\subsubsection{Test de unidad para el módulo IP Host}

En este caso, el test implementado es para testear el comportamiento del protocolo IP para los hosts, la única diferencia entre este protocolo IP y el protocolo IP de los routers es que en este caso, se trabaja con la capa superior (UDP) y es necesario encapsular los udp::Segments en ip::Datagrams para forwardearlos por la red. Para este sencillo test se simula el proceso recién mencionado. La Figura \ref{figure: unit test ip host} muestra es escenario para este test de unidad.

\begin{figure}[!h]
    \centering
    \includegraphics[width = 0.35\textwidth]{img/png/unit_tests/ip_host.png}
    \caption{Src 1 genera input de tipo udp::Segment, src 2 genera input de tipo link::Control. Sink 1 imprime output de tipo link::Control mientras que Sink 2 y 3 imprimen el input generado por Src 1 y Src 2.}
    \label{figure: unit test ip host}
\end{figure}

El input y output del test se puede ver en el apendice \ref{appendix: ip_host unit test}

\subsubsection{Test de unidad para el módulo IP Router}

Para el caso del protocolo IP en routers se implementó un escenario donde a diferencia del anterior para IP en hosts, en este caso llega un ip::Datagram proveniente de la red y el mismo es forwardeado ya que un router no tiene capa 4 y todo ip::Datagram que llega es forwardeado para llegar a su destino o descartado si no pasa las verificaciones como checksum o su campo \textit{TTL} es 0. La Figura \ref{figure: unit test ip router} muestra el escenario par este test.\\

\begin{figure}[!thb]
    \centering
    \includegraphics[width = 0.35\textwidth]{img/png/unit_tests/ip_router.png}
    \caption{Src 1 genera input de tipo ip::Datagram, src 2 genera input de tipo link::Control. Sink 1 imprime output de tipo link::Control mientras que Sink 2 y 3 imprimen el input generado por Src 1 y Src 2.}
    \label{figure: unit test ip router}
\end{figure}

El input y output del test se puede ver en el apendice \ref{appendix: ip_router unit test}

\newpage

\subsubsection{Test de unidad para el módulo link}

Por último, el test de unidad para el módulo link, el cual implementa \textit{ARP} y \textit{SWP}, fue testeado con un escenario en el cual le llega un link::Frame de un nodo de la red que es aceptado. El frame entrante, es un frame de datos que contiene un ip::Datagram que es desencapsulado y entregado a la capa superior. Luego de haber entregado el ip::Datagram, el protocolo \textit{SWP} se encarga de enviar un \textit{Ack} al nodo que envió el frame para notificarle que llegó correctamente y que este pueda actualizar su ventana \textit{SWS} y seguir enviando más frames en un futuro. La Figura \ref{figure: unit test link} Muestra el escenario en la IDE PowerDEVS para este test. \\

\begin{figure}[!h]
    \centering
    \includegraphics[width = 0.45\textwidth]{img/png/unit_tests/link.png}
    \caption{Src 1 genera input de tipo link::Frame, Sink 1 imprime output de tipo ip::Datagram, Sink 2 imprime output de tipo link::Frame mientras que Sink 3 imprime el input generado por Src 1.}
    \label{figure: unit test link}
\end{figure}

El input y output del test se puede ver en el apendice \ref{appendix: link unit test}

\subsection{Test de integración - Escenario implementado}

Para finalizar y a modo de test de integración, se implementó un modelo de una red y se simuló un escenario donde todos los módulos funcionan en conjuntos para enviar mensajes entre los \textit{host} de dicha red. El escenario implementado en este trabajo está pensado para cubrir de forma minimal los eventos relevantes en el envío de mensajes a través de la red tales como: Pasar por múltiples \textit{routers}, enviar mensajes a otro host de la misma red y enviar mensajes a un \textit{host} de una red donde es el único \textit{host}. Dado que se implementó \textit{DNS}, el escenario también busca mostrar un ejemplo donde se ejecuten tanto pedidos recursivos como pedidos iterativos a los distintos servidores \textit{DNS}. Para conseguir esto, se planteó el escenario mostrado en la Figura \ref{figure: case study}, el mismo cuenta con cinco \textit{subnets} con diferentes cantidades de \textit{switches} y \textit{hosts}, las \textit{subnets} $2$ y $3$ no cuentan con dispositivos extras a los \textit{routers} a los cuales están conectadas ya que no aportaría nada al test. Las Figuras \ref{figure: powerdevs host}, \ref{figure: powerdevs router}, \ref{figure: powerdevs interfaces} y \ref{figure: powerdevs switch} muestran los modelos acoplados de dispositivos hosts routers y switches correspondientes al escenario planteado. \\

En este escenario, el host 2 es el servidor local para la \textit{subnet} 1, el host 5 es el host TLD mientras que el host 4 es el host responsable de la zona ``.com'' y el host 3 es el host responsable para la zona ``.devs.com'' con lo cual, el es autoritativo para el dominio ``networks.devs.com''. En esta simulación el host 1 le pide a su servidor local (host 2) que resuelva el dominio ``networks.devs.com'' de forma recursiva, el mismo al no tener esa entrada en su cache, envía el pedido al servidor TLD (host 5) quien no tiene la respuesta pero sabe que pertenece a la zona ``.com'' y le envía un mensaje diciéndole que el host 4 es el responsable de esa zona, también le envía el \textit{IP} del host 4 para que sepa como llegar a el, el host 2 envía entonces la misma consulta al host 4 y repitiéndose lo mismo que antes, el host 4 al no tener la respuesta pero saber que el host 3 es responsable de la zona más puntual ``.devs.com'', le envía el \textit{IP} del host 3 y repitiendo el proceso, el host 2 le envía el mismo pedido al host 3 quien si tiene la respuesta. Una vez con la respuesta, el host 2 la agrega a su cache, para que se mantenga ahí hasta que se venza su \textit{TTL} y y se la envía al host 1. El input y output de la simulación del test se puede ver en el apendice \ref{appendix: integration test} \\

\newpage

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 1.0\textwidth]{img/png/scenario.png}
    \caption{Escenario implementado: Las lineas azules numeradas muestran el intercambio de paquetes \textit{DNS} entre los hosts y el orden secuencial con el que sea realizan estos intercambios, mientras que las lineas negras muestran las conexiones de la red por donde efectivamente se envían los paquetes, teniendo que pasar por múltiples switches y routers para ir de un host a otro. Los números al lado de los switches muestran el mapeo de puertos para el protocolo \textit{Datagram}.}
    \label{figure: case study}
\end{figure}

\newpage

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.5\textwidth]{img/png/powerdevs/host.png}
    \caption{Modelo PowerDEVS de un dispositivo Host con las capas \textit{DNS}, \textit{UDP}, \textit{IPv4} y \textit{Link}; Se pueden ver las conexiones realizadas entre cada una de las capas del moselo UDP/IP asi como el generador y el vertedero correspondientes al input y output de este modelo. Los puertos externos (Inport0 y outport0) permiten conectar el modelo dispositivo a otro dispositivo de la red para enviar los mensajes.}
    \label{figure: powerdevs host}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.6\textwidth]{img/png/powerdevs/router.png}
    \caption{Modelo PowerDEVS de un dispositivo Router con las capas \textit{IPv4} y \textit{Link}; Se puede ver que la capa Link tiene 5 puertos de entrada y salida en vez de 4. Esto es porque como se mencionó en la arquitectura del modelo, la capa 1 cuenta con 2 puertos para la comunicación con la capa 2 y con k puertos para la entrada y salida del dispositivo, uno por cada interfaz, en este caso $k = 3$.}
    \label{figure: powerdevs router}
\end{figure}

\newpage

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.6\textwidth]{img/png/powerdevs/router_interfaces.png}
    \caption{Modelo PowerDEVS de la capa Link del router ; el router debe elegir mediante la \textit{forwarding table} por cual interfaz (modelo link) enviar el mensaje dependiendo a que \textit{subnet} quiera alcanzar. La interfaz viaja en el mensaje multiplexado y el \textit{demultiplexer} es quien lo dirige al modelo \textit{Link} que corresponda. Como se ve, el input y output de cada interfaz al dispositivo se realiza de forma directa, entonces, un mensaje que viene por el puerto 2 va a ir a la interfaz Link r1, por lo que un mensaje enviado al router desde una \textit{subnet} no puede llegar a otra interfaz del router que la interfaz de la misma \textit{subnet}.}
    \label{figure: powerdevs interfaces}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width = 0.8\textwidth]{img/png/powerdevs/switch.png}
    \caption{Modelo PowerDEVS de un dispositivo \textit{Switch} que cuenta con una sola capa en la cual implementa el protocolo \textit{Datagram} y \textit{SWP}. Utiliza un multiplexer y demultiplexer para saber de cuál interfaz llego el mensaje y para elegir por cual o cuales interfaces enviar el mensaje.}
    \label{figure: powerdevs switch}
\end{figure}

\section{Conclusiones}
Si bien existen varias herramientas para la implementación de modelado y simulación de redes de comunicaciones, en este trabajo se pudo observar varias ventajas extras, algunas de ellas desde el punto de vista formal y otras desde el punto de vista educativo. Desde el punto de vista formal, se logró implementar el modelo OSI e implementar un modelo UDP/IP que funcione sobre el mismo, permitiendo modelar las formalidades de las ideas más teóricas de los protocolos de forma práctica, además, este trabajo cuenta con todos los beneficios heredados al utilizar el formalismo DEVS. Desde el punto de vista educativo, se observa la ventaja principal de poder contar con un modelo más intuitivo para la enseñanza y aprendizaje de redes que se abstrae de las dificultades técnicas existentes en herramientas de modelado más complejas pero que pueden no aportar al entendimiento de los temas. \\

Personalmente, siento que en este trabajo se logró modelar a los protocolos como entidades individuales abstrayéndolos lo suficiente de los aspectos generales de las redes, lo que me permitió estudiar y comprender mejor sus interacciones y mecanismos, separar los aspectos generales de los protocolos (necesario para el buen funcionamiento del sistema) de los aspectos particulares de los mismos (necesarios para la robustez y funcionamiento particular de cada entidad del sistema) así como comprender y separar las ideas de los protocolos horizontales (cada capa se comunica con la capa del mismo nivel del otro nodo) respecto de su implementación final vertical (cada protocolo envía y recibe paquetes mediante la capa inferior). Por otro lado, implementar un modelo que se amolde lo mejor posible a la teoría pero que tenga funcionamiento práctico me permitió comprender mejor la distancia existente entre ambos mundos. Creo que estos aspectos mencionados si bien son personales, se derivan directamente de la arquitectura propuesta en este trabajo y pueden ser adquiridas por cualquier estudiante que utilice NetworkDEVS para aprender sobre los temas del área.

\section{trabajo futuro}

\subsection{Automatizar la implementación de los modelos acoplados Layer}
Si bien en este trabajo se implementó la arquitectura general del framework de trabajo para modelar redes, las estructuras de los modelos acoplados de las capas y sus parámetros deben actualmente ser implementadas a mano por el modelador y requiere la realización de trabajo mecánico por parte del mismo. Esta tarea además de consumir mucho tiempo y ser tediosa, es propensa a errores del programador fácilmente evitables si el mismo fuera automatizado. Por lo que un trabajo futuro muy útil para mejorar la usabilidad de está herramienta es la implementación de un generador de estructuras acopladas donde el usuario especifique datos tales como:

\begin{itemize}
\item Ubicaciones de los archivos donde está implementado el o los protocolos de la capa.
\item Los parámetros de los protocolos.
\item Los ids para los demultiplexers.
\end{itemize}

\subsection{Generador automático de topologías}
De la misma forma que se puede automatizar la creación de los modelos capas, también se puede automatizar la creación de distintas topología. Ya existe una herramienta para la creación de topologías integradas a PowerDEVS \cite{laurito2017topogen}, solo es necesario integrar a esa herramienta la arquitectura de NetworkDEVS.

\subsection{Mejoras al modelo del caso de estudio}
\begin{itemize}
\item Como ya fue mencionado anteriormente, en el modelo implementado en este trabajo no se implementó ningún protocolo dinámico para el llenado de las distintas tablas utilizadas (routing table, forwarding table, etc.), sería muy interesante implementar estos protocolos para poder tener un caso de estudió más completo del funcionamiento de una red.
\end{itemize}

\newpage

\bibliographystyle{plain}
\bibliography{references}

\newpage

\appendix
\section{Logs generados por los tests}
\label{appendix: logs}
En esta sección se encuentran todos los logs de las simulaciónes realizada tanto para los test de unidad como para el test de integración del modelo.

\subsection{Logs del test de unidad del módulo DNS}
\label{appendix: dns unit test}

A continuación se muestra el input, output y log del test de unidad del modelo DNS.\\

\textbf{Input port 0 (dns::DomainName)}
\lstinputlisting[language=Bash]{../tests/dns/output/input_domain_name.output}

\textbf{Input port 2 (dns::Packet)}
\lstinputlisting[language=Bash]{../tests/dns/output/input_dns_packet.output}

\textbf{Output port 0 (dns::Packet)}
\lstinputlisting[language=Bash]{../tests/dns/output/dns_packet.output}

\textbf{Output port 3 (udp::Control)}
\lstinputlisting[language=Bash]{../tests/dns/output/udp_control.output}

\textbf{Output generado por el logger durante la simulación}
\begin{lstlisting}
[INFO] - [DNS Test] DNS local ip: 1.0.0.1
[INFO] - [DNS Test] DNS root server ip: 1.0.0.2
[INFO] - [DNS Test] No authoritative RR table file.
[INFO] - [DNS Test] No zone server table file.
[INFO] - [DNS Test] Recursive allowed: True
Simulation Initialized
[INFO] - [DNS Test] Process domain name network.devs.com
[INFO] - [DNS Test] Domain not in cache
[INFO] - [DNS Test] Send DNS Query to: (1.0.0.2, 53)
[INFO] - [DNS Test] Incoming packet:
[INFO] - [DNS Test] 
-------------- dns packet ---------------
** HEADER ** 
id: 0
flags_code: 0
QDCount: 1
ANCount: 1
NSCount: 0
ARCount: 1

** QUESTION SECTION ** 
network.devs.com A 0.0.0.0 IN 0 

** ANSWER SECTION ** 
network.devs.com A 1.0.0.3 IN 65 

** AUTHORITATIVES SECTION ** 

** ADITIONAL SECTION ** 
network.devs.com A 1.0.0.1 IN 0 
-----------------------------------------
[INFO] - [DNS Test] Answer packet
[INFO] - [DNS Test] Answer Type: A
Simulation Ended (0.000862 sec)
\end{lstlisting}

\newpage

\subsection{Logs del test de unidad del modelo UDP}
\label{appendix: udp unit test}
A continuación se muestra el input, output y log del test de unidad del modelo UDP.\\

\textbf{Input port 1 (udp::Control)}
\lstinputlisting[language=Bash]{../tests/udp/output/input_udp_control.output}

\textbf{Input port 2 (udp::Segment)}
\lstinputlisting[language=Bash]{../tests/udp/output/input_udp_segment.output}

\textbf{Output port 1 (udp::Control)}
\lstinputlisting[language=Bash]{../tests/udp/output/udp_control.output}

\textbf{Output port 2 (udp::Segment)}
\lstinputlisting[language=Bash]{../tests/udp/output/udp_segment.output}

\textbf{Output generado por el logger durante la simulación}
\begin{lstlisting}
Simulation Initialized
[INFO] - [UDP Test] Connect
[INFO] - [UDP Test] SUCCESS
[INFO] - [UDP Test] Write/Send
[INFO] - [UDP Test] Write/Send
[INFO] - [UDP Test] Bind
[INFO] - [UDP Test] SUCCESS
[INFO] - [UDP Test] process Segment: 
[INFO] - [UDP Test] local_port: 80
[INFO] - [UDP Test] remote_port: 80
[INFO] - [UDP Test] local_ip: 1.0.0.1
[INFO] - [UDP Test] remote_ip: 1.0.0.2
[INFO] - [UDP Test] valid checksum: False
[INFO] - [UDP Test] discarted segment.
[INFO] - [UDP Test] Write_to/Send_to
[INFO] - [UDP Test] Write/Send
[INFO] - [UDP Test] INVALID_SOCKET
Simulation Ended (0.00135 sec)
\end{lstlisting}

\newpage

\subsection{Logs del test de unidad del modelo IP en un host}
\label{appendix: ip_host unit test}
A continuación se muestra el input, output y log del test de unidad del modelo IP en un host.\\

\textbf{Input port 0 (udp::Segment)}
\lstinputlisting[language=Bash]{../tests/ip/host/output/input_udp_segment.output}

\textbf{Input port 3 (link::Control)}
\lstinputlisting[language=Bash]{../tests/ip/host/output/input_link_control.output}

\textbf{Output port 3 (link::Control)}
\lstinputlisting[language=Bash]{../tests/ip/host/output/link_control.output}

\textbf{Output generado por el logger durante la simulación}
\begin{lstlisting}
[INFO] - [IPv4 Test] ip amount: 1
[INFO] - [IPv4 Test] ips:
[INFO] - [IPv4 Test] 1.0.0.1
[INFO] - [IPv4 Test] Routing table:
[INFO] - [IPv4 Test] | 0.0.0.0 | 0.0.0.0          | 1.0.0.0 | 1 | Default Route |
[INFO] - [IPv4 Test] | 1.0.0.2 | 255.255.255.255  | 1.0.0.2 | 1 | Host 2 |
[INFO] - [IPv4 Test] Forwarding table:
[INFO] - [IPv4 Test] | 0.0.0.0 | 0.0.0.0 | 0 
[INFO] - [Demultiplexer Host 1] Initialized with 1 interfaces
Simulation Initialized
[INFO] - [IPv4 Test] Forwarding ip packet: 1.0.0.2
[INFO] - [IPv4 Test] Best route for packet with dest_ip: 1.0.0.2 
is: | 1.0.0.2 | 255.255.255.255 | 1.0.0.2 | 1 | Host 2 | 
[INFO] - [IPv4 Test] Added packet to wait ARP for nexthop: 1.0.0.2
[INFO] - [IPv4 Test] ARP query throw interface: NET 0
[INFO] - [IPv4 Test] link::Ctrl::ARP_READY
Simulation Ended (0.000886 sec)
\end{lstlisting}

\newpage

\subsection{Logs del test de unidad del modelo IP en un router}
\label{appendix: ip_router unit test}
A continuación se muestra el input, output y log del test de unidad del modelo IP en un router.\\

\textbf{Input port 2 (ip::Datagram)}
\lstinputlisting[language=Bash]{../tests/ip/router/output/input_ip_datagram.output}

\textbf{Input port 3 (link::Control)}
\lstinputlisting[language=Bash]{../tests/ip/router/output/input_link_control.output}

\textbf{Output port 3 (link::Control)}
\lstinputlisting[language=Bash]{../tests/ip/router/output/link_control.output}

\textbf{Output generado por el logger durante la simulación}
\begin{lstlisting}
[INFO] - [IPv4 Test] ip amount: 1
[INFO] - [IPv4 Test] ips:
[INFO] - [IPv4 Test] 1.0.0.1
[INFO] - [IPv4 Test] Routing table:
[INFO] - [IPv4 Test] | 0.0.0.0 | 0.0.0.0         | 1.0.0.0 | 1 | Default Route | 
[INFO] - [IPv4 Test] | 1.0.0.2 | 255.255.255.255 | 1.0.0.2 | 1 | Host 2 | 
[INFO] - [IPv4 Test] Forwarding table:
[INFO] - [IPv4 Test] | 0.0.0.0 | 0.0.0.0 | 0 | 
[INFO] - [Demultiplexer Host 1] Initialized with 1 interfaces
Simulation Initialized
[INFO] - [IPv4 Test] Process Ip Datagram
[INFO] - [IPv4 Test] Valid checksum: true
[INFO] - [IPv4 Test] Forwarding ip packet: 1.0.0.2
[INFO] - [IPv4 Test] Best route for packet with dest_ip 
is: 1.0.0.2 is: | 1.0.0.2 | 255.255.255.255 | 1.0.0.2 | 1 | Host 2 | 
[INFO] - [IPv4 Test] Added packet to wait ARP for nexthop: 1.0.0.2
[INFO] - [IPv4 Test] ARP query throw interface: NET 0
[INFO] - [IPv4 Test] link::Ctrl::ARP_READY
Simulation Ended (0.000795 sec)
\end{lstlisting}

\newpage

\subsection{Logs del test de unidad del modelo Link}
\label{appendix: link unit test}
A continuación se muestra el input, output y log del test de unidad del modelo Link.\\

\textbf{Input port 2 (link::Frame)}
\lstinputlisting[language=Bash]{../tests/link/output/input_link_frame.output}

\textbf{Input port 0 (ip::Datagram)}
\lstinputlisting[language=Bash]{../tests/link/output/ip_datagram.output}

\textbf{Output port 2 (link::Frame)}
\lstinputlisting[language=Bash]{../tests/link/output/link_frame.output}

\textbf{Output generado por el logger durante la simulación}
\begin{lstlisting}
[INFO] - [Link Test] MAC: 0:0:0:0:0:1
[INFO] - [Link Test] IP: 1.0.0.2
[INFO] - [Link Test] Interface: 0
Simulation Initialized
[INFO] - [SWP Test] swp_protocol::processFrame
[INFO] - [SWP Test] Deliver frame with SeqNum: 1
[INFO] - [SWP Test] send ACK LFR: 1
Simulation Ended (0.000283 sec)
\end{lstlisting}

\newpage

\subsection{Logs del test de integración}
\label{appendix: integration test}

A continuación se presentan los resultados del escenario con el mismo formato que se presentaron para los test de unidad. Primero se presenta el input y ouput de la simulación en el cual se detalla para cada tiempo virtual, el mensaje entrante o saliente del modelo. La documentación respecto al formato de los mensajes se puede ver en la misma documentación Doxygen del código. Luego se muestra el log generado por el logger, el mismo se muestra primero separado por capas (\textit{link, ip, udp}, etc.) permitiendo ver el funcionamiento horizontal de cada capa, en donde se desconoce lo máximo posible la existencia de capas inferiores y los mensajes son enviados a la misma capa de otro nodo de la red, y luego se muestra el log completo para poder ver el funcionamiento entre las capas y la relación temporal de los eventos ocurridos en la simulación. \\

\textbf{Host 1 - DNS - Input port 0 (dns::DomainName)}
\lstinputlisting[language=Bash]{../scenario/output/h1_input.output}

\textbf{Host 1 - DNS - Output port 0 (dns::Packet)}
\lstinputlisting[language=Bash]{../scenario/output/h1.output}

Como se puede ver, primero llega el mensaje entrante con el nombre de dominio para el cual se quiere resolver su \textit{IP} y luego, una vez resueltas todas las consultas recursivas e iterativas a los distintos servidores, se consigue la respuesta indicando que el \textit{IP} vinculado al dominio ``networks.devs.com'' es 6.0.0.1. A continuación se muestran los logs de la simulación que muestra todo lo ocurrido para conseguir resolver el pedido, involucrando a todas las capas y dispositivos de la red. \\

\textbf{Output de la capa DNS generado por el logger durante la simulación}
\lstinputlisting[language=Bash]{../scenario/logs/DNS.log}

\textbf{Output de la capa UDP generado por el logger durante la simulación}
\lstinputlisting[language=Bash]{../scenario/logs/UDP.log}

\textbf{Output de la capa IP generado por el logger durante la simulación}
\lstinputlisting[language=Bash]{../scenario/logs/IPv4.log}

\textbf{Output del módulo LINK generado por el logger durante la simulación}
\lstinputlisting[language=Bash]{../scenario/logs/Link.log}

\textbf{Output del módulo SWITCH generado por el logger durante la simulación}
\lstinputlisting[language=Bash]{../scenario/logs/Switch.log}

\textbf{Output del módulo SWP generado por el logger durante la simulación}
\lstinputlisting[language=Bash]{../scenario/logs/SWP.log}

\textbf{Output de todo el scenario integrado generado por el logger durante la simulación}
\lstinputlisting[language=Bash]{../scenario/logs/top.log}

\end{document}
