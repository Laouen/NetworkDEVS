\hypertarget{classmessage_1_1queue}{}\section{message\+:\+:queue$<$ M\+SG $>$ Struct Template Reference}
\label{classmessage_1_1queue}\index{message\+::queue$<$ M\+S\+G $>$@{message\+::queue$<$ M\+S\+G $>$}}


Implement a queue to output messages through ports in Power\+D\+E\+VS models.  




{\ttfamily \#include $<$message\+\_\+queue.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmessage_1_1queue_ac166e11137e5addc2f81b672c9b55c4d}{queue} ()
\begin{DoxyCompactList}\small\item\em Default constructor that does no specifies neither port nor interface numbers. \end{DoxyCompactList}\item 
\hyperlink{classmessage_1_1queue_a6d303f8450ddfc4f1cffd80e94e25f0a}{queue} (ushort other\+\_\+default\+\_\+port)
\begin{DoxyCompactList}\small\item\em Constructor with port number. \end{DoxyCompactList}\item 
\hyperlink{classmessage_1_1queue_a34787cab8e5205524bbebe4343033c62}{queue} (ushort other\+\_\+default\+\_\+port, ushort other\+\_\+default\+\_\+interface)
\begin{DoxyCompactList}\small\item\em Constructor with port and interface number. \end{DoxyCompactList}\item 
void \hyperlink{classmessage_1_1queue_a6b5fbac4cdd0c3a563e3d8f8422e2cb1}{clear} ()\hypertarget{classmessage_1_1queue_a6b5fbac4cdd0c3a563e3d8f8422e2cb1}{}\label{classmessage_1_1queue_a6b5fbac4cdd0c3a563e3d8f8422e2cb1}

\begin{DoxyCompactList}\small\item\em removes all the pushed messages from the queue. \end{DoxyCompactList}\item 
void \hyperlink{classmessage_1_1queue_ae84717161f68aa5fee8b158afe7e9a75}{set\+\_\+multiplexed} (bool other\+\_\+multiplexer)
\begin{DoxyCompactList}\small\item\em Interface to set a new value for the multiplexed attribute used to determines if messages must be send multiplexed or not. \end{DoxyCompactList}\item 
void \hyperlink{classmessage_1_1queue_a473ab65bba7f707e59710b22343a62bf}{push} (const M\+SG \&message, ushort interface, ushort port)
\begin{DoxyCompactList}\small\item\em Adds a new message at the end of the queue seting a specific interface and port numbers where to send the message when poped. \end{DoxyCompactList}\item 
void \hyperlink{classmessage_1_1queue_a961d33eeb52a8733669c74c18289e6bb}{push} (const M\+SG \&message, ushort interface)
\begin{DoxyCompactList}\small\item\em Adds a new message at the end of the queue seting a specific interface and uses the default port to send the message when poped. \end{DoxyCompactList}\item 
void \hyperlink{classmessage_1_1queue_a295edb53a69103cd3c6607cf40546c20}{push} (const M\+SG \&message)
\begin{DoxyCompactList}\small\item\em Adds a new message at the end of the queue seting the default interface and the default port to send the message when poped. \end{DoxyCompactList}\item 
Event \hyperlink{classmessage_1_1queue_a8ebd25ce589eca4dd4b1afde687df705}{pop} ()
\begin{DoxyCompactList}\small\item\em Removes the next element from the queue in F\+I\+FO order and returns the Power\+D\+E\+VS Event instance to send the message. \end{DoxyCompactList}\item 
Event \hyperlink{classmessage_1_1queue_a5fb6a671faf783c7bd13caa69451ca84}{send} (const M\+SG \&message, ushort port)
\begin{DoxyCompactList}\small\item\em This method does not push the message in the queue and instead it directly generates a Power\+D\+E\+VS Event instance with a pointer to the message asociated with the port number passed as parameter and the and the default\+\_\+interface. \end{DoxyCompactList}\item 
Event \hyperlink{classmessage_1_1queue_a95abcec7e979fbc1233204c5d87865b1}{send} (const M\+SG \&message, ushort interface, ushort port)
\begin{DoxyCompactList}\small\item\em This method does not push the message in the queue and instead it directly generates a Power\+D\+E\+VS Event instance with a pointer to the message asociated with the port and interface numbers passed as parameter. \end{DoxyCompactList}\item 
bool \hyperlink{classmessage_1_1queue_ab03011f8c323c553b3f8b6d5c84ae9db}{empty} ()
\begin{DoxyCompactList}\small\item\em Checks whether the \hyperlink{classmessage_1_1queue}{message\+::queue} is empty or not. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename M\+SG$>$\\*
struct message\+::queue$<$ M\+S\+G $>$}

Implement a queue to output messages through ports in Power\+D\+E\+VS models. 

\begin{DoxyAuthor}{Author}
Laouen Louan Mayal Belloli 
\end{DoxyAuthor}
\begin{DoxyDate}{Date}
14 May 2017
\end{DoxyDate}
Each instance of a queue is asociated with a port and interface number and every message that is pushed into the queue will be sent through that port if no output port is explicitated in the push method. If the multiplexed attribute is true, then the message is send as multiplexed using the interface number. This queue handles the void $\ast$ requested by the Power\+D\+E\+VS keeping the pointed object alive until the next pop is done and the message was already delivered to the corresponding model or models. \hyperlink{classmessage_1_1queue}{message\+::queue} allows to push multiple messages to be send and send them one by one using the pop method that returns a Power\+D\+E\+VS valid Event instance ready to be sent in the lambda function with the next message in the queue and the port set in it.


\begin{DoxyTemplParams}{Template Parameters}
{\em M\+SG} & Data type of the messages that will output the queue \\
\hline
\end{DoxyTemplParams}


\subsection{Constructor \& Destructor Documentation}
\index{message\+::queue@{message\+::queue}!queue@{queue}}
\index{queue@{queue}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{queue()}{queue()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ {\bf message\+::queue}$<$ M\+SG $>$\+::{\bf queue} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_ac166e11137e5addc2f81b672c9b55c4d}{}\label{classmessage_1_1queue_ac166e11137e5addc2f81b672c9b55c4d}


Default constructor that does no specifies neither port nor interface numbers. 

defaul values are\+: port = 0. interface = 0; multiplexed = true. \index{message\+::queue@{message\+::queue}!queue@{queue}}
\index{queue@{queue}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{queue(ushort other\+\_\+default\+\_\+port)}{queue(ushort other_default_port)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ {\bf message\+::queue}$<$ M\+SG $>$\+::{\bf queue} (
\begin{DoxyParamCaption}
\item[{ushort}]{other\+\_\+default\+\_\+port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_a6d303f8450ddfc4f1cffd80e94e25f0a}{}\label{classmessage_1_1queue_a6d303f8450ddfc4f1cffd80e94e25f0a}


Constructor with port number. 

This constructor initialize a new \hyperlink{classmessage_1_1queue}{message\+::queue} instance with a default port number that will be used each time a message is pushed without passing a port number as parameter. Defaul values are\+: interface = 0; multiplexed = true.


\begin{DoxyParams}{Parameters}
{\em other\+\_\+default\+\_\+port} & A unsigned short that specifies the default port number. \\
\hline
\end{DoxyParams}
\index{message\+::queue@{message\+::queue}!queue@{queue}}
\index{queue@{queue}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{queue(ushort other\+\_\+default\+\_\+port, ushort other\+\_\+default\+\_\+interface)}{queue(ushort other_default_port, ushort other_default_interface)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ {\bf message\+::queue}$<$ M\+SG $>$\+::{\bf queue} (
\begin{DoxyParamCaption}
\item[{ushort}]{other\+\_\+default\+\_\+port, }
\item[{ushort}]{other\+\_\+default\+\_\+interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_a34787cab8e5205524bbebe4343033c62}{}\label{classmessage_1_1queue_a34787cab8e5205524bbebe4343033c62}


Constructor with port and interface number. 

This constructor initialize a new \hyperlink{classmessage_1_1queue}{message\+::queue} instance with default port and interface numbers that will be used each time a message is pushed without passing any port and interface numbers as parameter. Defaul values are\+: multiplexed = true.


\begin{DoxyParams}{Parameters}
{\em other\+\_\+default\+\_\+port} & A unsigned short that specifies the default port number. \\
\hline
{\em other\+\_\+default\+\_\+interface} & A unsigned short that specifies the default interface number. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\index{message\+::queue@{message\+::queue}!empty@{empty}}
\index{empty@{empty}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{empty()}{empty()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ bool {\bf message\+::queue}$<$ M\+SG $>$\+::empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_ab03011f8c323c553b3f8b6d5c84ae9db}{}\label{classmessage_1_1queue_ab03011f8c323c553b3f8b6d5c84ae9db}


Checks whether the \hyperlink{classmessage_1_1queue}{message\+::queue} is empty or not. 

\begin{DoxyReturn}{Returns}
True if the message\+:queue is empty, False otherwise. 
\end{DoxyReturn}
\index{message\+::queue@{message\+::queue}!pop@{pop}}
\index{pop@{pop}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{pop()}{pop()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ Event {\bf message\+::queue}$<$ M\+SG $>$\+::pop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_a8ebd25ce589eca4dd4b1afde687df705}{}\label{classmessage_1_1queue_a8ebd25ce589eca4dd4b1afde687df705}


Removes the next element from the queue in F\+I\+FO order and returns the Power\+D\+E\+VS Event instance to send the message. 

The removed object is stored in memory until the next pop is made to ensure the void $\ast$ used by the simulator does point to a valid memory place.

\begin{DoxyReturn}{Returns}
A Power\+D\+E\+VS Event instance that contains the poped message asociated with the port used to push the message in the queue. 
\end{DoxyReturn}
\index{message\+::queue@{message\+::queue}!push@{push}}
\index{push@{push}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{push(const M\+S\+G \&message, ushort interface, ushort port)}{push(const MSG &message, ushort interface, ushort port)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ void {\bf message\+::queue}$<$ M\+SG $>$\+::push (
\begin{DoxyParamCaption}
\item[{const M\+SG \&}]{message, }
\item[{ushort}]{interface, }
\item[{ushort}]{port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_a473ab65bba7f707e59710b22343a62bf}{}\label{classmessage_1_1queue_a473ab65bba7f707e59710b22343a62bf}


Adds a new message at the end of the queue seting a specific interface and port numbers where to send the message when poped. 


\begin{DoxyParams}{Parameters}
{\em message} & A M\+SG message to push. \\
\hline
{\em interface} & An unsigned short that specifies the interface number where to multiplex the message when poped. \\
\hline
{\em port} & An unsigned short that specifies the interfaz number where to send the message when poped. \\
\hline
\end{DoxyParams}
\index{message\+::queue@{message\+::queue}!push@{push}}
\index{push@{push}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{push(const M\+S\+G \&message, ushort interface)}{push(const MSG &message, ushort interface)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ void {\bf message\+::queue}$<$ M\+SG $>$\+::push (
\begin{DoxyParamCaption}
\item[{const M\+SG \&}]{message, }
\item[{ushort}]{interface}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_a961d33eeb52a8733669c74c18289e6bb}{}\label{classmessage_1_1queue_a961d33eeb52a8733669c74c18289e6bb}


Adds a new message at the end of the queue seting a specific interface and uses the default port to send the message when poped. 


\begin{DoxyParams}{Parameters}
{\em message} & A M\+SG message to push. \\
\hline
{\em interface} & An unsigned short that specifies the interfaz number where to multiplex the message when poped. \\
\hline
\end{DoxyParams}
\index{message\+::queue@{message\+::queue}!push@{push}}
\index{push@{push}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{push(const M\+S\+G \&message)}{push(const MSG &message)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ void {\bf message\+::queue}$<$ M\+SG $>$\+::push (
\begin{DoxyParamCaption}
\item[{const M\+SG \&}]{message}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_a295edb53a69103cd3c6607cf40546c20}{}\label{classmessage_1_1queue_a295edb53a69103cd3c6607cf40546c20}


Adds a new message at the end of the queue seting the default interface and the default port to send the message when poped. 


\begin{DoxyParams}{Parameters}
{\em message} & A M\+SG message to push. \\
\hline
\end{DoxyParams}
\index{message\+::queue@{message\+::queue}!send@{send}}
\index{send@{send}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{send(const M\+S\+G \&message, ushort port)}{send(const MSG &message, ushort port)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ Event {\bf message\+::queue}$<$ M\+SG $>$\+::send (
\begin{DoxyParamCaption}
\item[{const M\+SG \&}]{message, }
\item[{ushort}]{port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_a5fb6a671faf783c7bd13caa69451ca84}{}\label{classmessage_1_1queue_a5fb6a671faf783c7bd13caa69451ca84}


This method does not push the message in the queue and instead it directly generates a Power\+D\+E\+VS Event instance with a pointer to the message asociated with the port number passed as parameter and the and the default\+\_\+interface. 

This metod behave as a pop where the poped message is the one passed as parameter, the message pointer is handled in the same way a poped message pointer is handled. This method can be used to avoid the message be pushed if the one is a priority over all pushed mesasges.


\begin{DoxyParams}{Parameters}
{\em message} & A M\+SG to be send. \\
\hline
{\em port} & A unsigned short that indicates the port where to send the message. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Power\+D\+E\+VS Event instance that contains the message asociated with the port number passed as parameter. 
\end{DoxyReturn}
\index{message\+::queue@{message\+::queue}!send@{send}}
\index{send@{send}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{send(const M\+S\+G \&message, ushort interface, ushort port)}{send(const MSG &message, ushort interface, ushort port)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ Event {\bf message\+::queue}$<$ M\+SG $>$\+::send (
\begin{DoxyParamCaption}
\item[{const M\+SG \&}]{message, }
\item[{ushort}]{interface, }
\item[{ushort}]{port}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_a95abcec7e979fbc1233204c5d87865b1}{}\label{classmessage_1_1queue_a95abcec7e979fbc1233204c5d87865b1}


This method does not push the message in the queue and instead it directly generates a Power\+D\+E\+VS Event instance with a pointer to the message asociated with the port and interface numbers passed as parameter. 

This metod behave as a pop where the poped message is the one passed as parameter, the message pointer is handled in the same way a poped message pointer is handled. This method can be used to avoid the message be pushed if the one is a priority over all pushed mesasges.


\begin{DoxyParams}{Parameters}
{\em message} & A M\+SG to be send. \\
\hline
{\em interface} & A unsigned short that indicates the interface to multiplex the message. \\
\hline
{\em port} & A unsigned short that indicates the port where to send the message. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A Power\+D\+E\+VS Event instance that contains the message asociated with the port number passed as parameter. 
\end{DoxyReturn}
\index{message\+::queue@{message\+::queue}!set\+\_\+multiplexed@{set\+\_\+multiplexed}}
\index{set\+\_\+multiplexed@{set\+\_\+multiplexed}!message\+::queue@{message\+::queue}}
\subsubsection[{\texorpdfstring{set\+\_\+multiplexed(bool other\+\_\+multiplexer)}{set_multiplexed(bool other_multiplexer)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename M\+SG$>$ void {\bf message\+::queue}$<$ M\+SG $>$\+::set\+\_\+multiplexed (
\begin{DoxyParamCaption}
\item[{bool}]{other\+\_\+multiplexer}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\hypertarget{classmessage_1_1queue_ae84717161f68aa5fee8b158afe7e9a75}{}\label{classmessage_1_1queue_ae84717161f68aa5fee8b158afe7e9a75}


Interface to set a new value for the multiplexed attribute used to determines if messages must be send multiplexed or not. 


\begin{DoxyParams}{Parameters}
{\em other\+\_\+multiplexer} & A boolean that will be set as the new multiplexed attribute value. \\
\hline
\end{DoxyParams}


The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/lao/powerdevs/atomics/\+Network\+D\+E\+V\+S/libs/message\+\_\+queue.\+h\end{DoxyCompactItemize}
